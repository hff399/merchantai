"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@cryptography";
exports.ids = ["vendor-chunks/@cryptography"];
exports.modules = {

/***/ "(rsc)/./node_modules/@cryptography/aes/dist/es/aes.js":
/*!*******************************************************!*\
  !*** ./node_modules/@cryptography/aes/dist/es/aes.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CTR: () => (/* binding */ AES_IGE$1),\n/* harmony export */   IGE: () => (/* binding */ AES_IGE),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\nvar S = new Uint8Array(256);\nvar Si = new Uint8Array(256);\nvar T1 = new Uint32Array(256);\nvar T2 = new Uint32Array(256);\nvar T3 = new Uint32Array(256);\nvar T4 = new Uint32Array(256);\nvar T5 = new Uint32Array(256);\nvar T6 = new Uint32Array(256);\nvar T7 = new Uint32Array(256);\nvar T8 = new Uint32Array(256);\nfunction computeTables() {\n    var d = new Uint8Array(256);\n    var t = new Uint8Array(256);\n    var x2;\n    var x4;\n    var x8;\n    var s;\n    var tEnc;\n    var tDec;\n    var x = 0;\n    var xInv = 0;\n    // Compute double and third tables\n    for (var i = 0; i < 256; i++) {\n        d[i] = i << 1 ^ (i >> 7) * 283;\n        t[d[i] ^ i] = i;\n    }\n    for (; !S[x]; x ^= x2 || 1) {\n        // Compute sbox\n        s = xInv ^ xInv << 1 ^ xInv << 2 ^ xInv << 3 ^ xInv << 4;\n        s = s >> 8 ^ s & 255 ^ 99;\n        S[x] = s;\n        Si[s] = x;\n        // Compute MixColumns\n        x8 = d[x4 = d[x2 = d[x]]];\n        tDec = x8 * 0x1010101 ^ x4 * 0x10001 ^ x2 * 0x101 ^ x * 0x1010100;\n        tEnc = d[s] * 0x101 ^ s * 0x1010100;\n        T1[x] = tEnc = tEnc << 24 ^ tEnc >>> 8;\n        T2[x] = tEnc = tEnc << 24 ^ tEnc >>> 8;\n        T3[x] = tEnc = tEnc << 24 ^ tEnc >>> 8;\n        T4[x] = tEnc = tEnc << 24 ^ tEnc >>> 8;\n        T5[s] = tDec = tDec << 24 ^ tDec >>> 8;\n        T6[s] = tDec = tDec << 24 ^ tDec >>> 8;\n        T7[s] = tDec = tDec << 24 ^ tDec >>> 8;\n        T8[s] = tDec = tDec << 24 ^ tDec >>> 8;\n        xInv = t[xInv] || 1;\n    }\n}\n\n/**\n * Gets a uint32 from string in big-endian order order\n */\nfunction s2i(str, pos) {\n    return (str.charCodeAt(pos) << 24\n        ^ str.charCodeAt(pos + 1) << 16\n        ^ str.charCodeAt(pos + 2) << 8\n        ^ str.charCodeAt(pos + 3));\n}\n\n/* eslint-disable import/prefer-default-export */\n/**\n * Helper function for transforming string key to Uint32Array\n */\nfunction getWords(key) {\n    if (key instanceof Uint32Array) {\n        return key;\n    }\n    if (typeof key === 'string') {\n        if (key.length % 4 !== 0)\n            for (var i = key.length % 4; i <= 4; i++)\n                key += '\\0x00';\n        var buf = new Uint32Array(key.length / 4);\n        for (var i = 0; i < key.length; i += 4)\n            buf[i / 4] = s2i(key, i);\n        return buf;\n    }\n    if (key instanceof Uint8Array) {\n        var buf = new Uint32Array(key.length / 4);\n        for (var i = 0; i < key.length; i += 4) {\n            buf[i / 4] = (key[i] << 24\n                ^ key[i + 1] << 16\n                ^ key[i + 2] << 8\n                ^ key[i + 3]);\n        }\n        return buf;\n    }\n    throw new Error('Unable to create 32-bit words');\n}\nfunction xor(left, right, to) {\n    if (to === void 0) { to = left; }\n    for (var i = 0; i < left.length; i++)\n        to[i] = left[i] ^ right[i];\n}\n\ncomputeTables();\n/**\n * Low-level AES Cipher\n */\nvar AES = /** @class */ (function () {\n    function AES(_key) {\n        var key = getWords(_key);\n        if (key.length !== 4 && key.length !== 6 && key.length !== 8) {\n            throw new Error('Invalid key size');\n        }\n        this.encKey = new Uint32Array(4 * key.length + 28);\n        this.decKey = new Uint32Array(4 * key.length + 28);\n        this.encKey.set(key);\n        var rcon = 1;\n        var i = key.length;\n        var tmp;\n        // schedule encryption keys\n        for (; i < 4 * key.length + 28; i++) {\n            tmp = this.encKey[i - 1];\n            // apply sbox\n            if (i % key.length === 0 || (key.length === 8 && i % key.length === 4)) {\n                tmp = S[tmp >>> 24] << 24 ^ S[(tmp >> 16) & 255] << 16 ^ S[(tmp >> 8) & 255] << 8 ^ S[tmp & 255];\n                // shift rows and add rcon\n                if (i % key.length === 0) {\n                    tmp = tmp << 8 ^ tmp >>> 24 ^ (rcon << 24);\n                    rcon = rcon << 1 ^ (rcon >> 7) * 283;\n                }\n            }\n            this.encKey[i] = this.encKey[i - key.length] ^ tmp;\n        }\n        // schedule decryption keys\n        for (var j = 0; i; j++, i--) {\n            tmp = this.encKey[j & 3 ? i : i - 4];\n            if (i <= 4 || j < 4) {\n                this.decKey[j] = tmp;\n            }\n            else {\n                this.decKey[j] = (T5[S[tmp >>> 24]]\n                    ^ T6[S[(tmp >> 16) & 255]]\n                    ^ T7[S[(tmp >> 8) & 255]]\n                    ^ T8[S[tmp & 255]]);\n            }\n        }\n    }\n    AES.prototype.encrypt = function (_message) {\n        var message = getWords(_message);\n        var out = new Uint32Array(4);\n        var a = message[0] ^ this.encKey[0];\n        var b = message[1] ^ this.encKey[1];\n        var c = message[2] ^ this.encKey[2];\n        var d = message[3] ^ this.encKey[3];\n        var rounds = this.encKey.length / 4 - 2;\n        var k = 4;\n        var a2;\n        var b2;\n        var c2;\n        // Inner rounds.  Cribbed from OpenSSL.\n        for (var i = 0; i < rounds; i++) {\n            a2 = T1[a >>> 24] ^ T2[(b >> 16) & 255] ^ T3[(c >> 8) & 255] ^ T4[d & 255] ^ this.encKey[k];\n            b2 = T1[b >>> 24] ^ T2[(c >> 16) & 255] ^ T3[(d >> 8) & 255] ^ T4[a & 255] ^ this.encKey[k + 1];\n            c2 = T1[c >>> 24] ^ T2[(d >> 16) & 255] ^ T3[(a >> 8) & 255] ^ T4[b & 255] ^ this.encKey[k + 2];\n            d = T1[d >>> 24] ^ T2[(a >> 16) & 255] ^ T3[(b >> 8) & 255] ^ T4[c & 255] ^ this.encKey[k + 3];\n            a = a2;\n            b = b2;\n            c = c2;\n            k += 4;\n            // console.log(a, b, c, d);\n        }\n        // Last round.\n        for (var i = 0; i < 4; i++) {\n            out[i] = (S[a >>> 24] << 24\n                ^ S[(b >> 16) & 255] << 16\n                ^ S[(c >> 8) & 255] << 8\n                ^ S[d & 255]\n                ^ this.encKey[k++]);\n            a2 = a;\n            a = b;\n            b = c;\n            c = d;\n            d = a2;\n        }\n        return out;\n    };\n    AES.prototype.decrypt = function (_message) {\n        var message = getWords(_message);\n        var out = new Uint32Array(4);\n        var a = message[0] ^ this.decKey[0];\n        var b = message[3] ^ this.decKey[1];\n        var c = message[2] ^ this.decKey[2];\n        var d = message[1] ^ this.decKey[3];\n        var rounds = this.decKey.length / 4 - 2;\n        var a2;\n        var b2;\n        var c2;\n        var k = 4;\n        // Inner rounds.  Cribbed from OpenSSL.\n        for (var i = 0; i < rounds; i++) {\n            a2 = T5[a >>> 24] ^ T6[(b >> 16) & 255] ^ T7[(c >> 8) & 255] ^ T8[d & 255] ^ this.decKey[k];\n            b2 = T5[b >>> 24] ^ T6[(c >> 16) & 255] ^ T7[(d >> 8) & 255] ^ T8[a & 255] ^ this.decKey[k + 1];\n            c2 = T5[c >>> 24] ^ T6[(d >> 16) & 255] ^ T7[(a >> 8) & 255] ^ T8[b & 255] ^ this.decKey[k + 2];\n            d = T5[d >>> 24] ^ T6[(a >> 16) & 255] ^ T7[(b >> 8) & 255] ^ T8[c & 255] ^ this.decKey[k + 3];\n            a = a2;\n            b = b2;\n            c = c2;\n            k += 4;\n        }\n        // Last round.\n        for (var i = 0; i < 4; i++) {\n            out[3 & -i] = (Si[a >>> 24] << 24\n                ^ Si[(b >> 16) & 255] << 16\n                ^ Si[(c >> 8) & 255] << 8\n                ^ Si[d & 255]\n                ^ this.decKey[k++]);\n            a2 = a;\n            a = b;\n            b = c;\n            c = d;\n            d = a2;\n        }\n        return out;\n    };\n    return AES;\n}());\n\n/**\n * AES-IGE mode.\n */\nvar AES_IGE = /** @class */ (function () {\n    function AES_IGE(key, iv, blockSize) {\n        if (blockSize === void 0) { blockSize = 16; }\n        this.key = getWords(key);\n        this.iv = getWords(iv);\n        this.cipher = new AES(key);\n        this.blockSize = blockSize / 4;\n    }\n    /**\n     * Encrypts plain text with AES-IGE mode.\n     */\n    AES_IGE.prototype.encrypt = function (message, buf) {\n        var text = getWords(message);\n        var cipherText = buf || new Uint32Array(text.length);\n        var prevX = this.iv.subarray(this.blockSize, this.iv.length);\n        var prevY = this.iv.subarray(0, this.blockSize);\n        var yXOR = new Uint32Array(this.blockSize);\n        for (var i = 0; i < text.length; i += this.blockSize) {\n            var x = text.subarray(i, i + this.blockSize);\n            xor(x, prevY, yXOR);\n            var y = this.cipher.encrypt(yXOR);\n            xor(y, prevX);\n            prevX = x;\n            prevY = y;\n            for (var j = i, k = 0; j < text.length && k < 4; j++, k++)\n                cipherText[j] = y[k];\n        }\n        return cipherText;\n    };\n    /**\n     * Decrypts cipher text with AES-IGE mode.\n     */\n    AES_IGE.prototype.decrypt = function (message, buf) {\n        var cipherText = getWords(message);\n        var text = buf || new Uint32Array(cipherText.length);\n        var prevY = this.iv.subarray(this.blockSize, this.iv.length);\n        var prevX = this.iv.subarray(0, this.blockSize);\n        var yXOR = new Uint32Array(this.blockSize);\n        for (var i = 0; i < text.length; i += this.blockSize) {\n            var x = cipherText.subarray(i, i + this.blockSize);\n            xor(x, prevY, yXOR);\n            var y = this.cipher.decrypt(yXOR);\n            xor(y, prevX);\n            prevX = x;\n            prevY = y;\n            for (var j = i, k = 0; j < text.length && k < 4; j++, k++)\n                text[j] = y[k];\n        }\n        return text;\n    };\n    return AES_IGE;\n}());\n\n/**\n * AES-IGE mode.\n */\nvar AES_IGE$1 = /** @class */ (function () {\n    function AES_IGE(key, counter, blockSize) {\n        if (blockSize === void 0) { blockSize = 16; }\n        this.offset = 0;\n        this.key = getWords(key);\n        this.counter = getWords(counter);\n        this.cipher = new AES(key);\n        this.blockSize = blockSize / 4;\n        if (this.counter.length !== 4) {\n            throw new Error('AES-CTR mode counter must be 16 bytes length');\n        }\n    }\n    /**\n     * Encrypts plain text with AES-IGE mode.\n     */\n    AES_IGE.prototype.encrypt = function (message, buf) {\n        var text = getWords(message);\n        var cipherText = buf || new Uint32Array(text.length);\n        var offset = this.offset;\n        for (var i = 0; i < text.length; i += this.blockSize) {\n            var x = this.cipher.encrypt(this.counter);\n            for (var j = i, k = offset; j < text.length && k < this.blockSize; j++, k++)\n                cipherText[j] = x[k] ^ text[j];\n            if (text.length - i >= this.blockSize)\n                this.incrementCounter();\n            if (offset) {\n                i -= offset;\n                offset = 0;\n            }\n        }\n        this.offset = (this.offset + (text.length % 4)) % 4;\n        return cipherText;\n    };\n    /**\n     * Decrypts cipher text with AES-IGE mode.\n     */\n    AES_IGE.prototype.decrypt = function (message, buf) {\n        return this.encrypt(message, buf);\n    };\n    AES_IGE.prototype.incrementCounter = function () {\n        // increment counter\n        for (var carry = this.counter.length - 1; carry >= 0; carry--) {\n            if (++this.counter[carry] < 0xFFFFFFFF)\n                break; // If overflowing, it'll be 0 and we'll have to continue propagating the carry\n        }\n    };\n    return AES_IGE;\n}());\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (AES);\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGNyeXB0b2dyYXBoeS9hZXMvZGlzdC9lcy9hZXMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsU0FBUztBQUM3QjtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsUUFBUTtBQUNqRDtBQUNBO0FBQ0Esd0JBQXdCLGdCQUFnQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGdCQUFnQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QixvQkFBb0IsaUJBQWlCO0FBQ3JDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUseUJBQXlCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLEdBQUc7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsWUFBWTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLE9BQU87QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixZQUFZO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLE9BQU87QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGlCQUFpQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsMEJBQTBCO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGlCQUFpQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsMEJBQTBCO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsaUJBQWlCO0FBQ3pDO0FBQ0Esd0NBQXdDLHVDQUF1QztBQUMvRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxZQUFZO0FBQzlEO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQsaUVBQWUsR0FBRyxFQUFDO0FBQ3lCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbWVyY2hhbnRhaS1hZG1pbi8uL25vZGVfbW9kdWxlcy9AY3J5cHRvZ3JhcGh5L2Flcy9kaXN0L2VzL2Flcy5qcz81ZTVmIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBTID0gbmV3IFVpbnQ4QXJyYXkoMjU2KTtcbnZhciBTaSA9IG5ldyBVaW50OEFycmF5KDI1Nik7XG52YXIgVDEgPSBuZXcgVWludDMyQXJyYXkoMjU2KTtcbnZhciBUMiA9IG5ldyBVaW50MzJBcnJheSgyNTYpO1xudmFyIFQzID0gbmV3IFVpbnQzMkFycmF5KDI1Nik7XG52YXIgVDQgPSBuZXcgVWludDMyQXJyYXkoMjU2KTtcbnZhciBUNSA9IG5ldyBVaW50MzJBcnJheSgyNTYpO1xudmFyIFQ2ID0gbmV3IFVpbnQzMkFycmF5KDI1Nik7XG52YXIgVDcgPSBuZXcgVWludDMyQXJyYXkoMjU2KTtcbnZhciBUOCA9IG5ldyBVaW50MzJBcnJheSgyNTYpO1xuZnVuY3Rpb24gY29tcHV0ZVRhYmxlcygpIHtcbiAgICB2YXIgZCA9IG5ldyBVaW50OEFycmF5KDI1Nik7XG4gICAgdmFyIHQgPSBuZXcgVWludDhBcnJheSgyNTYpO1xuICAgIHZhciB4MjtcbiAgICB2YXIgeDQ7XG4gICAgdmFyIHg4O1xuICAgIHZhciBzO1xuICAgIHZhciB0RW5jO1xuICAgIHZhciB0RGVjO1xuICAgIHZhciB4ID0gMDtcbiAgICB2YXIgeEludiA9IDA7XG4gICAgLy8gQ29tcHV0ZSBkb3VibGUgYW5kIHRoaXJkIHRhYmxlc1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgMjU2OyBpKyspIHtcbiAgICAgICAgZFtpXSA9IGkgPDwgMSBeIChpID4+IDcpICogMjgzO1xuICAgICAgICB0W2RbaV0gXiBpXSA9IGk7XG4gICAgfVxuICAgIGZvciAoOyAhU1t4XTsgeCBePSB4MiB8fCAxKSB7XG4gICAgICAgIC8vIENvbXB1dGUgc2JveFxuICAgICAgICBzID0geEludiBeIHhJbnYgPDwgMSBeIHhJbnYgPDwgMiBeIHhJbnYgPDwgMyBeIHhJbnYgPDwgNDtcbiAgICAgICAgcyA9IHMgPj4gOCBeIHMgJiAyNTUgXiA5OTtcbiAgICAgICAgU1t4XSA9IHM7XG4gICAgICAgIFNpW3NdID0geDtcbiAgICAgICAgLy8gQ29tcHV0ZSBNaXhDb2x1bW5zXG4gICAgICAgIHg4ID0gZFt4NCA9IGRbeDIgPSBkW3hdXV07XG4gICAgICAgIHREZWMgPSB4OCAqIDB4MTAxMDEwMSBeIHg0ICogMHgxMDAwMSBeIHgyICogMHgxMDEgXiB4ICogMHgxMDEwMTAwO1xuICAgICAgICB0RW5jID0gZFtzXSAqIDB4MTAxIF4gcyAqIDB4MTAxMDEwMDtcbiAgICAgICAgVDFbeF0gPSB0RW5jID0gdEVuYyA8PCAyNCBeIHRFbmMgPj4+IDg7XG4gICAgICAgIFQyW3hdID0gdEVuYyA9IHRFbmMgPDwgMjQgXiB0RW5jID4+PiA4O1xuICAgICAgICBUM1t4XSA9IHRFbmMgPSB0RW5jIDw8IDI0IF4gdEVuYyA+Pj4gODtcbiAgICAgICAgVDRbeF0gPSB0RW5jID0gdEVuYyA8PCAyNCBeIHRFbmMgPj4+IDg7XG4gICAgICAgIFQ1W3NdID0gdERlYyA9IHREZWMgPDwgMjQgXiB0RGVjID4+PiA4O1xuICAgICAgICBUNltzXSA9IHREZWMgPSB0RGVjIDw8IDI0IF4gdERlYyA+Pj4gODtcbiAgICAgICAgVDdbc10gPSB0RGVjID0gdERlYyA8PCAyNCBeIHREZWMgPj4+IDg7XG4gICAgICAgIFQ4W3NdID0gdERlYyA9IHREZWMgPDwgMjQgXiB0RGVjID4+PiA4O1xuICAgICAgICB4SW52ID0gdFt4SW52XSB8fCAxO1xuICAgIH1cbn1cblxuLyoqXG4gKiBHZXRzIGEgdWludDMyIGZyb20gc3RyaW5nIGluIGJpZy1lbmRpYW4gb3JkZXIgb3JkZXJcbiAqL1xuZnVuY3Rpb24gczJpKHN0ciwgcG9zKSB7XG4gICAgcmV0dXJuIChzdHIuY2hhckNvZGVBdChwb3MpIDw8IDI0XG4gICAgICAgIF4gc3RyLmNoYXJDb2RlQXQocG9zICsgMSkgPDwgMTZcbiAgICAgICAgXiBzdHIuY2hhckNvZGVBdChwb3MgKyAyKSA8PCA4XG4gICAgICAgIF4gc3RyLmNoYXJDb2RlQXQocG9zICsgMykpO1xufVxuXG4vKiBlc2xpbnQtZGlzYWJsZSBpbXBvcnQvcHJlZmVyLWRlZmF1bHQtZXhwb3J0ICovXG4vKipcbiAqIEhlbHBlciBmdW5jdGlvbiBmb3IgdHJhbnNmb3JtaW5nIHN0cmluZyBrZXkgdG8gVWludDMyQXJyYXlcbiAqL1xuZnVuY3Rpb24gZ2V0V29yZHMoa2V5KSB7XG4gICAgaWYgKGtleSBpbnN0YW5jZW9mIFVpbnQzMkFycmF5KSB7XG4gICAgICAgIHJldHVybiBrZXk7XG4gICAgfVxuICAgIGlmICh0eXBlb2Yga2V5ID09PSAnc3RyaW5nJykge1xuICAgICAgICBpZiAoa2V5Lmxlbmd0aCAlIDQgIT09IDApXG4gICAgICAgICAgICBmb3IgKHZhciBpID0ga2V5Lmxlbmd0aCAlIDQ7IGkgPD0gNDsgaSsrKVxuICAgICAgICAgICAgICAgIGtleSArPSAnXFwweDAwJztcbiAgICAgICAgdmFyIGJ1ZiA9IG5ldyBVaW50MzJBcnJheShrZXkubGVuZ3RoIC8gNCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5Lmxlbmd0aDsgaSArPSA0KVxuICAgICAgICAgICAgYnVmW2kgLyA0XSA9IHMyaShrZXksIGkpO1xuICAgICAgICByZXR1cm4gYnVmO1xuICAgIH1cbiAgICBpZiAoa2V5IGluc3RhbmNlb2YgVWludDhBcnJheSkge1xuICAgICAgICB2YXIgYnVmID0gbmV3IFVpbnQzMkFycmF5KGtleS5sZW5ndGggLyA0KTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXkubGVuZ3RoOyBpICs9IDQpIHtcbiAgICAgICAgICAgIGJ1ZltpIC8gNF0gPSAoa2V5W2ldIDw8IDI0XG4gICAgICAgICAgICAgICAgXiBrZXlbaSArIDFdIDw8IDE2XG4gICAgICAgICAgICAgICAgXiBrZXlbaSArIDJdIDw8IDhcbiAgICAgICAgICAgICAgICBeIGtleVtpICsgM10pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBidWY7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcignVW5hYmxlIHRvIGNyZWF0ZSAzMi1iaXQgd29yZHMnKTtcbn1cbmZ1bmN0aW9uIHhvcihsZWZ0LCByaWdodCwgdG8pIHtcbiAgICBpZiAodG8gPT09IHZvaWQgMCkgeyB0byA9IGxlZnQ7IH1cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlZnQubGVuZ3RoOyBpKyspXG4gICAgICAgIHRvW2ldID0gbGVmdFtpXSBeIHJpZ2h0W2ldO1xufVxuXG5jb21wdXRlVGFibGVzKCk7XG4vKipcbiAqIExvdy1sZXZlbCBBRVMgQ2lwaGVyXG4gKi9cbnZhciBBRVMgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQUVTKF9rZXkpIHtcbiAgICAgICAgdmFyIGtleSA9IGdldFdvcmRzKF9rZXkpO1xuICAgICAgICBpZiAoa2V5Lmxlbmd0aCAhPT0gNCAmJiBrZXkubGVuZ3RoICE9PSA2ICYmIGtleS5sZW5ndGggIT09IDgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBrZXkgc2l6ZScpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZW5jS2V5ID0gbmV3IFVpbnQzMkFycmF5KDQgKiBrZXkubGVuZ3RoICsgMjgpO1xuICAgICAgICB0aGlzLmRlY0tleSA9IG5ldyBVaW50MzJBcnJheSg0ICoga2V5Lmxlbmd0aCArIDI4KTtcbiAgICAgICAgdGhpcy5lbmNLZXkuc2V0KGtleSk7XG4gICAgICAgIHZhciByY29uID0gMTtcbiAgICAgICAgdmFyIGkgPSBrZXkubGVuZ3RoO1xuICAgICAgICB2YXIgdG1wO1xuICAgICAgICAvLyBzY2hlZHVsZSBlbmNyeXB0aW9uIGtleXNcbiAgICAgICAgZm9yICg7IGkgPCA0ICoga2V5Lmxlbmd0aCArIDI4OyBpKyspIHtcbiAgICAgICAgICAgIHRtcCA9IHRoaXMuZW5jS2V5W2kgLSAxXTtcbiAgICAgICAgICAgIC8vIGFwcGx5IHNib3hcbiAgICAgICAgICAgIGlmIChpICUga2V5Lmxlbmd0aCA9PT0gMCB8fCAoa2V5Lmxlbmd0aCA9PT0gOCAmJiBpICUga2V5Lmxlbmd0aCA9PT0gNCkpIHtcbiAgICAgICAgICAgICAgICB0bXAgPSBTW3RtcCA+Pj4gMjRdIDw8IDI0IF4gU1sodG1wID4+IDE2KSAmIDI1NV0gPDwgMTYgXiBTWyh0bXAgPj4gOCkgJiAyNTVdIDw8IDggXiBTW3RtcCAmIDI1NV07XG4gICAgICAgICAgICAgICAgLy8gc2hpZnQgcm93cyBhbmQgYWRkIHJjb25cbiAgICAgICAgICAgICAgICBpZiAoaSAlIGtleS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdG1wID0gdG1wIDw8IDggXiB0bXAgPj4+IDI0IF4gKHJjb24gPDwgMjQpO1xuICAgICAgICAgICAgICAgICAgICByY29uID0gcmNvbiA8PCAxIF4gKHJjb24gPj4gNykgKiAyODM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5lbmNLZXlbaV0gPSB0aGlzLmVuY0tleVtpIC0ga2V5Lmxlbmd0aF0gXiB0bXA7XG4gICAgICAgIH1cbiAgICAgICAgLy8gc2NoZWR1bGUgZGVjcnlwdGlvbiBrZXlzXG4gICAgICAgIGZvciAodmFyIGogPSAwOyBpOyBqKyssIGktLSkge1xuICAgICAgICAgICAgdG1wID0gdGhpcy5lbmNLZXlbaiAmIDMgPyBpIDogaSAtIDRdO1xuICAgICAgICAgICAgaWYgKGkgPD0gNCB8fCBqIDwgNCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZGVjS2V5W2pdID0gdG1wO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kZWNLZXlbal0gPSAoVDVbU1t0bXAgPj4+IDI0XV1cbiAgICAgICAgICAgICAgICAgICAgXiBUNltTWyh0bXAgPj4gMTYpICYgMjU1XV1cbiAgICAgICAgICAgICAgICAgICAgXiBUN1tTWyh0bXAgPj4gOCkgJiAyNTVdXVxuICAgICAgICAgICAgICAgICAgICBeIFQ4W1NbdG1wICYgMjU1XV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIEFFUy5wcm90b3R5cGUuZW5jcnlwdCA9IGZ1bmN0aW9uIChfbWVzc2FnZSkge1xuICAgICAgICB2YXIgbWVzc2FnZSA9IGdldFdvcmRzKF9tZXNzYWdlKTtcbiAgICAgICAgdmFyIG91dCA9IG5ldyBVaW50MzJBcnJheSg0KTtcbiAgICAgICAgdmFyIGEgPSBtZXNzYWdlWzBdIF4gdGhpcy5lbmNLZXlbMF07XG4gICAgICAgIHZhciBiID0gbWVzc2FnZVsxXSBeIHRoaXMuZW5jS2V5WzFdO1xuICAgICAgICB2YXIgYyA9IG1lc3NhZ2VbMl0gXiB0aGlzLmVuY0tleVsyXTtcbiAgICAgICAgdmFyIGQgPSBtZXNzYWdlWzNdIF4gdGhpcy5lbmNLZXlbM107XG4gICAgICAgIHZhciByb3VuZHMgPSB0aGlzLmVuY0tleS5sZW5ndGggLyA0IC0gMjtcbiAgICAgICAgdmFyIGsgPSA0O1xuICAgICAgICB2YXIgYTI7XG4gICAgICAgIHZhciBiMjtcbiAgICAgICAgdmFyIGMyO1xuICAgICAgICAvLyBJbm5lciByb3VuZHMuICBDcmliYmVkIGZyb20gT3BlblNTTC5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByb3VuZHM7IGkrKykge1xuICAgICAgICAgICAgYTIgPSBUMVthID4+PiAyNF0gXiBUMlsoYiA+PiAxNikgJiAyNTVdIF4gVDNbKGMgPj4gOCkgJiAyNTVdIF4gVDRbZCAmIDI1NV0gXiB0aGlzLmVuY0tleVtrXTtcbiAgICAgICAgICAgIGIyID0gVDFbYiA+Pj4gMjRdIF4gVDJbKGMgPj4gMTYpICYgMjU1XSBeIFQzWyhkID4+IDgpICYgMjU1XSBeIFQ0W2EgJiAyNTVdIF4gdGhpcy5lbmNLZXlbayArIDFdO1xuICAgICAgICAgICAgYzIgPSBUMVtjID4+PiAyNF0gXiBUMlsoZCA+PiAxNikgJiAyNTVdIF4gVDNbKGEgPj4gOCkgJiAyNTVdIF4gVDRbYiAmIDI1NV0gXiB0aGlzLmVuY0tleVtrICsgMl07XG4gICAgICAgICAgICBkID0gVDFbZCA+Pj4gMjRdIF4gVDJbKGEgPj4gMTYpICYgMjU1XSBeIFQzWyhiID4+IDgpICYgMjU1XSBeIFQ0W2MgJiAyNTVdIF4gdGhpcy5lbmNLZXlbayArIDNdO1xuICAgICAgICAgICAgYSA9IGEyO1xuICAgICAgICAgICAgYiA9IGIyO1xuICAgICAgICAgICAgYyA9IGMyO1xuICAgICAgICAgICAgayArPSA0O1xuICAgICAgICAgICAgLy8gY29uc29sZS5sb2coYSwgYiwgYywgZCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gTGFzdCByb3VuZC5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCA0OyBpKyspIHtcbiAgICAgICAgICAgIG91dFtpXSA9IChTW2EgPj4+IDI0XSA8PCAyNFxuICAgICAgICAgICAgICAgIF4gU1soYiA+PiAxNikgJiAyNTVdIDw8IDE2XG4gICAgICAgICAgICAgICAgXiBTWyhjID4+IDgpICYgMjU1XSA8PCA4XG4gICAgICAgICAgICAgICAgXiBTW2QgJiAyNTVdXG4gICAgICAgICAgICAgICAgXiB0aGlzLmVuY0tleVtrKytdKTtcbiAgICAgICAgICAgIGEyID0gYTtcbiAgICAgICAgICAgIGEgPSBiO1xuICAgICAgICAgICAgYiA9IGM7XG4gICAgICAgICAgICBjID0gZDtcbiAgICAgICAgICAgIGQgPSBhMjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3V0O1xuICAgIH07XG4gICAgQUVTLnByb3RvdHlwZS5kZWNyeXB0ID0gZnVuY3Rpb24gKF9tZXNzYWdlKSB7XG4gICAgICAgIHZhciBtZXNzYWdlID0gZ2V0V29yZHMoX21lc3NhZ2UpO1xuICAgICAgICB2YXIgb3V0ID0gbmV3IFVpbnQzMkFycmF5KDQpO1xuICAgICAgICB2YXIgYSA9IG1lc3NhZ2VbMF0gXiB0aGlzLmRlY0tleVswXTtcbiAgICAgICAgdmFyIGIgPSBtZXNzYWdlWzNdIF4gdGhpcy5kZWNLZXlbMV07XG4gICAgICAgIHZhciBjID0gbWVzc2FnZVsyXSBeIHRoaXMuZGVjS2V5WzJdO1xuICAgICAgICB2YXIgZCA9IG1lc3NhZ2VbMV0gXiB0aGlzLmRlY0tleVszXTtcbiAgICAgICAgdmFyIHJvdW5kcyA9IHRoaXMuZGVjS2V5Lmxlbmd0aCAvIDQgLSAyO1xuICAgICAgICB2YXIgYTI7XG4gICAgICAgIHZhciBiMjtcbiAgICAgICAgdmFyIGMyO1xuICAgICAgICB2YXIgayA9IDQ7XG4gICAgICAgIC8vIElubmVyIHJvdW5kcy4gIENyaWJiZWQgZnJvbSBPcGVuU1NMLlxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJvdW5kczsgaSsrKSB7XG4gICAgICAgICAgICBhMiA9IFQ1W2EgPj4+IDI0XSBeIFQ2WyhiID4+IDE2KSAmIDI1NV0gXiBUN1soYyA+PiA4KSAmIDI1NV0gXiBUOFtkICYgMjU1XSBeIHRoaXMuZGVjS2V5W2tdO1xuICAgICAgICAgICAgYjIgPSBUNVtiID4+PiAyNF0gXiBUNlsoYyA+PiAxNikgJiAyNTVdIF4gVDdbKGQgPj4gOCkgJiAyNTVdIF4gVDhbYSAmIDI1NV0gXiB0aGlzLmRlY0tleVtrICsgMV07XG4gICAgICAgICAgICBjMiA9IFQ1W2MgPj4+IDI0XSBeIFQ2WyhkID4+IDE2KSAmIDI1NV0gXiBUN1soYSA+PiA4KSAmIDI1NV0gXiBUOFtiICYgMjU1XSBeIHRoaXMuZGVjS2V5W2sgKyAyXTtcbiAgICAgICAgICAgIGQgPSBUNVtkID4+PiAyNF0gXiBUNlsoYSA+PiAxNikgJiAyNTVdIF4gVDdbKGIgPj4gOCkgJiAyNTVdIF4gVDhbYyAmIDI1NV0gXiB0aGlzLmRlY0tleVtrICsgM107XG4gICAgICAgICAgICBhID0gYTI7XG4gICAgICAgICAgICBiID0gYjI7XG4gICAgICAgICAgICBjID0gYzI7XG4gICAgICAgICAgICBrICs9IDQ7XG4gICAgICAgIH1cbiAgICAgICAgLy8gTGFzdCByb3VuZC5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCA0OyBpKyspIHtcbiAgICAgICAgICAgIG91dFszICYgLWldID0gKFNpW2EgPj4+IDI0XSA8PCAyNFxuICAgICAgICAgICAgICAgIF4gU2lbKGIgPj4gMTYpICYgMjU1XSA8PCAxNlxuICAgICAgICAgICAgICAgIF4gU2lbKGMgPj4gOCkgJiAyNTVdIDw8IDhcbiAgICAgICAgICAgICAgICBeIFNpW2QgJiAyNTVdXG4gICAgICAgICAgICAgICAgXiB0aGlzLmRlY0tleVtrKytdKTtcbiAgICAgICAgICAgIGEyID0gYTtcbiAgICAgICAgICAgIGEgPSBiO1xuICAgICAgICAgICAgYiA9IGM7XG4gICAgICAgICAgICBjID0gZDtcbiAgICAgICAgICAgIGQgPSBhMjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3V0O1xuICAgIH07XG4gICAgcmV0dXJuIEFFUztcbn0oKSk7XG5cbi8qKlxuICogQUVTLUlHRSBtb2RlLlxuICovXG52YXIgQUVTX0lHRSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBBRVNfSUdFKGtleSwgaXYsIGJsb2NrU2l6ZSkge1xuICAgICAgICBpZiAoYmxvY2tTaXplID09PSB2b2lkIDApIHsgYmxvY2tTaXplID0gMTY7IH1cbiAgICAgICAgdGhpcy5rZXkgPSBnZXRXb3JkcyhrZXkpO1xuICAgICAgICB0aGlzLml2ID0gZ2V0V29yZHMoaXYpO1xuICAgICAgICB0aGlzLmNpcGhlciA9IG5ldyBBRVMoa2V5KTtcbiAgICAgICAgdGhpcy5ibG9ja1NpemUgPSBibG9ja1NpemUgLyA0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFbmNyeXB0cyBwbGFpbiB0ZXh0IHdpdGggQUVTLUlHRSBtb2RlLlxuICAgICAqL1xuICAgIEFFU19JR0UucHJvdG90eXBlLmVuY3J5cHQgPSBmdW5jdGlvbiAobWVzc2FnZSwgYnVmKSB7XG4gICAgICAgIHZhciB0ZXh0ID0gZ2V0V29yZHMobWVzc2FnZSk7XG4gICAgICAgIHZhciBjaXBoZXJUZXh0ID0gYnVmIHx8IG5ldyBVaW50MzJBcnJheSh0ZXh0Lmxlbmd0aCk7XG4gICAgICAgIHZhciBwcmV2WCA9IHRoaXMuaXYuc3ViYXJyYXkodGhpcy5ibG9ja1NpemUsIHRoaXMuaXYubGVuZ3RoKTtcbiAgICAgICAgdmFyIHByZXZZID0gdGhpcy5pdi5zdWJhcnJheSgwLCB0aGlzLmJsb2NrU2l6ZSk7XG4gICAgICAgIHZhciB5WE9SID0gbmV3IFVpbnQzMkFycmF5KHRoaXMuYmxvY2tTaXplKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0ZXh0Lmxlbmd0aDsgaSArPSB0aGlzLmJsb2NrU2l6ZSkge1xuICAgICAgICAgICAgdmFyIHggPSB0ZXh0LnN1YmFycmF5KGksIGkgKyB0aGlzLmJsb2NrU2l6ZSk7XG4gICAgICAgICAgICB4b3IoeCwgcHJldlksIHlYT1IpO1xuICAgICAgICAgICAgdmFyIHkgPSB0aGlzLmNpcGhlci5lbmNyeXB0KHlYT1IpO1xuICAgICAgICAgICAgeG9yKHksIHByZXZYKTtcbiAgICAgICAgICAgIHByZXZYID0geDtcbiAgICAgICAgICAgIHByZXZZID0geTtcbiAgICAgICAgICAgIGZvciAodmFyIGogPSBpLCBrID0gMDsgaiA8IHRleHQubGVuZ3RoICYmIGsgPCA0OyBqKyssIGsrKylcbiAgICAgICAgICAgICAgICBjaXBoZXJUZXh0W2pdID0geVtrXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2lwaGVyVGV4dDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIERlY3J5cHRzIGNpcGhlciB0ZXh0IHdpdGggQUVTLUlHRSBtb2RlLlxuICAgICAqL1xuICAgIEFFU19JR0UucHJvdG90eXBlLmRlY3J5cHQgPSBmdW5jdGlvbiAobWVzc2FnZSwgYnVmKSB7XG4gICAgICAgIHZhciBjaXBoZXJUZXh0ID0gZ2V0V29yZHMobWVzc2FnZSk7XG4gICAgICAgIHZhciB0ZXh0ID0gYnVmIHx8IG5ldyBVaW50MzJBcnJheShjaXBoZXJUZXh0Lmxlbmd0aCk7XG4gICAgICAgIHZhciBwcmV2WSA9IHRoaXMuaXYuc3ViYXJyYXkodGhpcy5ibG9ja1NpemUsIHRoaXMuaXYubGVuZ3RoKTtcbiAgICAgICAgdmFyIHByZXZYID0gdGhpcy5pdi5zdWJhcnJheSgwLCB0aGlzLmJsb2NrU2l6ZSk7XG4gICAgICAgIHZhciB5WE9SID0gbmV3IFVpbnQzMkFycmF5KHRoaXMuYmxvY2tTaXplKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0ZXh0Lmxlbmd0aDsgaSArPSB0aGlzLmJsb2NrU2l6ZSkge1xuICAgICAgICAgICAgdmFyIHggPSBjaXBoZXJUZXh0LnN1YmFycmF5KGksIGkgKyB0aGlzLmJsb2NrU2l6ZSk7XG4gICAgICAgICAgICB4b3IoeCwgcHJldlksIHlYT1IpO1xuICAgICAgICAgICAgdmFyIHkgPSB0aGlzLmNpcGhlci5kZWNyeXB0KHlYT1IpO1xuICAgICAgICAgICAgeG9yKHksIHByZXZYKTtcbiAgICAgICAgICAgIHByZXZYID0geDtcbiAgICAgICAgICAgIHByZXZZID0geTtcbiAgICAgICAgICAgIGZvciAodmFyIGogPSBpLCBrID0gMDsgaiA8IHRleHQubGVuZ3RoICYmIGsgPCA0OyBqKyssIGsrKylcbiAgICAgICAgICAgICAgICB0ZXh0W2pdID0geVtrXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGV4dDtcbiAgICB9O1xuICAgIHJldHVybiBBRVNfSUdFO1xufSgpKTtcblxuLyoqXG4gKiBBRVMtSUdFIG1vZGUuXG4gKi9cbnZhciBBRVNfSUdFJDEgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQUVTX0lHRShrZXksIGNvdW50ZXIsIGJsb2NrU2l6ZSkge1xuICAgICAgICBpZiAoYmxvY2tTaXplID09PSB2b2lkIDApIHsgYmxvY2tTaXplID0gMTY7IH1cbiAgICAgICAgdGhpcy5vZmZzZXQgPSAwO1xuICAgICAgICB0aGlzLmtleSA9IGdldFdvcmRzKGtleSk7XG4gICAgICAgIHRoaXMuY291bnRlciA9IGdldFdvcmRzKGNvdW50ZXIpO1xuICAgICAgICB0aGlzLmNpcGhlciA9IG5ldyBBRVMoa2V5KTtcbiAgICAgICAgdGhpcy5ibG9ja1NpemUgPSBibG9ja1NpemUgLyA0O1xuICAgICAgICBpZiAodGhpcy5jb3VudGVyLmxlbmd0aCAhPT0gNCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdBRVMtQ1RSIG1vZGUgY291bnRlciBtdXN0IGJlIDE2IGJ5dGVzIGxlbmd0aCcpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVuY3J5cHRzIHBsYWluIHRleHQgd2l0aCBBRVMtSUdFIG1vZGUuXG4gICAgICovXG4gICAgQUVTX0lHRS5wcm90b3R5cGUuZW5jcnlwdCA9IGZ1bmN0aW9uIChtZXNzYWdlLCBidWYpIHtcbiAgICAgICAgdmFyIHRleHQgPSBnZXRXb3JkcyhtZXNzYWdlKTtcbiAgICAgICAgdmFyIGNpcGhlclRleHQgPSBidWYgfHwgbmV3IFVpbnQzMkFycmF5KHRleHQubGVuZ3RoKTtcbiAgICAgICAgdmFyIG9mZnNldCA9IHRoaXMub2Zmc2V0O1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRleHQubGVuZ3RoOyBpICs9IHRoaXMuYmxvY2tTaXplKSB7XG4gICAgICAgICAgICB2YXIgeCA9IHRoaXMuY2lwaGVyLmVuY3J5cHQodGhpcy5jb3VudGVyKTtcbiAgICAgICAgICAgIGZvciAodmFyIGogPSBpLCBrID0gb2Zmc2V0OyBqIDwgdGV4dC5sZW5ndGggJiYgayA8IHRoaXMuYmxvY2tTaXplOyBqKyssIGsrKylcbiAgICAgICAgICAgICAgICBjaXBoZXJUZXh0W2pdID0geFtrXSBeIHRleHRbal07XG4gICAgICAgICAgICBpZiAodGV4dC5sZW5ndGggLSBpID49IHRoaXMuYmxvY2tTaXplKVxuICAgICAgICAgICAgICAgIHRoaXMuaW5jcmVtZW50Q291bnRlcigpO1xuICAgICAgICAgICAgaWYgKG9mZnNldCkge1xuICAgICAgICAgICAgICAgIGkgLT0gb2Zmc2V0O1xuICAgICAgICAgICAgICAgIG9mZnNldCA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5vZmZzZXQgPSAodGhpcy5vZmZzZXQgKyAodGV4dC5sZW5ndGggJSA0KSkgJSA0O1xuICAgICAgICByZXR1cm4gY2lwaGVyVGV4dDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIERlY3J5cHRzIGNpcGhlciB0ZXh0IHdpdGggQUVTLUlHRSBtb2RlLlxuICAgICAqL1xuICAgIEFFU19JR0UucHJvdG90eXBlLmRlY3J5cHQgPSBmdW5jdGlvbiAobWVzc2FnZSwgYnVmKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVuY3J5cHQobWVzc2FnZSwgYnVmKTtcbiAgICB9O1xuICAgIEFFU19JR0UucHJvdG90eXBlLmluY3JlbWVudENvdW50ZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIGluY3JlbWVudCBjb3VudGVyXG4gICAgICAgIGZvciAodmFyIGNhcnJ5ID0gdGhpcy5jb3VudGVyLmxlbmd0aCAtIDE7IGNhcnJ5ID49IDA7IGNhcnJ5LS0pIHtcbiAgICAgICAgICAgIGlmICgrK3RoaXMuY291bnRlcltjYXJyeV0gPCAweEZGRkZGRkZGKVxuICAgICAgICAgICAgICAgIGJyZWFrOyAvLyBJZiBvdmVyZmxvd2luZywgaXQnbGwgYmUgMCBhbmQgd2UnbGwgaGF2ZSB0byBjb250aW51ZSBwcm9wYWdhdGluZyB0aGUgY2FycnlcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIEFFU19JR0U7XG59KCkpO1xuXG5leHBvcnQgZGVmYXVsdCBBRVM7XG5leHBvcnQgeyBBRVNfSUdFJDEgYXMgQ1RSLCBBRVNfSUdFIGFzIElHRSB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@cryptography/aes/dist/es/aes.js\n");

/***/ })

};
;