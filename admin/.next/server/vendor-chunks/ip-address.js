"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/ip-address";
exports.ids = ["vendor-chunks/ip-address"];
exports.modules = {

/***/ "(rsc)/./node_modules/ip-address/dist/address-error.js":
/*!*******************************************************!*\
  !*** ./node_modules/ip-address/dist/address-error.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.AddressError = void 0;\nclass AddressError extends Error {\n    constructor(message, parseMessage) {\n        super(message);\n        this.name = 'AddressError';\n        this.parseMessage = parseMessage;\n    }\n}\nexports.AddressError = AddressError;\n//# sourceMappingURL=address-error.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaXAtYWRkcmVzcy9kaXN0L2FkZHJlc3MtZXJyb3IuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Qsb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbWVyY2hhbnRhaS1hZG1pbi8uL25vZGVfbW9kdWxlcy9pcC1hZGRyZXNzL2Rpc3QvYWRkcmVzcy1lcnJvci5qcz8wOWQzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5BZGRyZXNzRXJyb3IgPSB2b2lkIDA7XG5jbGFzcyBBZGRyZXNzRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gICAgY29uc3RydWN0b3IobWVzc2FnZSwgcGFyc2VNZXNzYWdlKSB7XG4gICAgICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgICAgICB0aGlzLm5hbWUgPSAnQWRkcmVzc0Vycm9yJztcbiAgICAgICAgdGhpcy5wYXJzZU1lc3NhZ2UgPSBwYXJzZU1lc3NhZ2U7XG4gICAgfVxufVxuZXhwb3J0cy5BZGRyZXNzRXJyb3IgPSBBZGRyZXNzRXJyb3I7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hZGRyZXNzLWVycm9yLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ip-address/dist/address-error.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ip-address/dist/common.js":
/*!************************************************!*\
  !*** ./node_modules/ip-address/dist/common.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.isInSubnet = isInSubnet;\nexports.isCorrect = isCorrect;\nexports.numberToPaddedHex = numberToPaddedHex;\nexports.stringToPaddedHex = stringToPaddedHex;\nexports.testBit = testBit;\nfunction isInSubnet(address) {\n    if (this.subnetMask < address.subnetMask) {\n        return false;\n    }\n    if (this.mask(address.subnetMask) === address.mask()) {\n        return true;\n    }\n    return false;\n}\nfunction isCorrect(defaultBits) {\n    return function () {\n        if (this.addressMinusSuffix !== this.correctForm()) {\n            return false;\n        }\n        if (this.subnetMask === defaultBits && !this.parsedSubnet) {\n            return true;\n        }\n        return this.parsedSubnet === String(this.subnetMask);\n    };\n}\nfunction numberToPaddedHex(number) {\n    return number.toString(16).padStart(2, '0');\n}\nfunction stringToPaddedHex(numberString) {\n    return numberToPaddedHex(parseInt(numberString, 10));\n}\n/**\n * @param binaryValue Binary representation of a value (e.g. `10`)\n * @param position Byte position, where 0 is the least significant bit\n */\nfunction testBit(binaryValue, position) {\n    const { length } = binaryValue;\n    if (position > length) {\n        return false;\n    }\n    const positionInString = length - position;\n    return binaryValue.substring(positionInString, positionInString + 1) === '1';\n}\n//# sourceMappingURL=common.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaXAtYWRkcmVzcy9kaXN0L2NvbW1vbi5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxrQkFBa0I7QUFDbEIsaUJBQWlCO0FBQ2pCLHlCQUF5QjtBQUN6Qix5QkFBeUI7QUFDekIsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxTQUFTO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbWVyY2hhbnRhaS1hZG1pbi8uL25vZGVfbW9kdWxlcy9pcC1hZGRyZXNzL2Rpc3QvY29tbW9uLmpzP2EzYmMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmlzSW5TdWJuZXQgPSBpc0luU3VibmV0O1xuZXhwb3J0cy5pc0NvcnJlY3QgPSBpc0NvcnJlY3Q7XG5leHBvcnRzLm51bWJlclRvUGFkZGVkSGV4ID0gbnVtYmVyVG9QYWRkZWRIZXg7XG5leHBvcnRzLnN0cmluZ1RvUGFkZGVkSGV4ID0gc3RyaW5nVG9QYWRkZWRIZXg7XG5leHBvcnRzLnRlc3RCaXQgPSB0ZXN0Qml0O1xuZnVuY3Rpb24gaXNJblN1Ym5ldChhZGRyZXNzKSB7XG4gICAgaWYgKHRoaXMuc3VibmV0TWFzayA8IGFkZHJlc3Muc3VibmV0TWFzaykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmICh0aGlzLm1hc2soYWRkcmVzcy5zdWJuZXRNYXNrKSA9PT0gYWRkcmVzcy5tYXNrKCkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGlzQ29ycmVjdChkZWZhdWx0Qml0cykge1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLmFkZHJlc3NNaW51c1N1ZmZpeCAhPT0gdGhpcy5jb3JyZWN0Rm9ybSgpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuc3VibmV0TWFzayA9PT0gZGVmYXVsdEJpdHMgJiYgIXRoaXMucGFyc2VkU3VibmV0KSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZWRTdWJuZXQgPT09IFN0cmluZyh0aGlzLnN1Ym5ldE1hc2spO1xuICAgIH07XG59XG5mdW5jdGlvbiBudW1iZXJUb1BhZGRlZEhleChudW1iZXIpIHtcbiAgICByZXR1cm4gbnVtYmVyLnRvU3RyaW5nKDE2KS5wYWRTdGFydCgyLCAnMCcpO1xufVxuZnVuY3Rpb24gc3RyaW5nVG9QYWRkZWRIZXgobnVtYmVyU3RyaW5nKSB7XG4gICAgcmV0dXJuIG51bWJlclRvUGFkZGVkSGV4KHBhcnNlSW50KG51bWJlclN0cmluZywgMTApKTtcbn1cbi8qKlxuICogQHBhcmFtIGJpbmFyeVZhbHVlIEJpbmFyeSByZXByZXNlbnRhdGlvbiBvZiBhIHZhbHVlIChlLmcuIGAxMGApXG4gKiBAcGFyYW0gcG9zaXRpb24gQnl0ZSBwb3NpdGlvbiwgd2hlcmUgMCBpcyB0aGUgbGVhc3Qgc2lnbmlmaWNhbnQgYml0XG4gKi9cbmZ1bmN0aW9uIHRlc3RCaXQoYmluYXJ5VmFsdWUsIHBvc2l0aW9uKSB7XG4gICAgY29uc3QgeyBsZW5ndGggfSA9IGJpbmFyeVZhbHVlO1xuICAgIGlmIChwb3NpdGlvbiA+IGxlbmd0aCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IHBvc2l0aW9uSW5TdHJpbmcgPSBsZW5ndGggLSBwb3NpdGlvbjtcbiAgICByZXR1cm4gYmluYXJ5VmFsdWUuc3Vic3RyaW5nKHBvc2l0aW9uSW5TdHJpbmcsIHBvc2l0aW9uSW5TdHJpbmcgKyAxKSA9PT0gJzEnO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29tbW9uLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ip-address/dist/common.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ip-address/dist/ip-address.js":
/*!****************************************************!*\
  !*** ./node_modules/ip-address/dist/ip-address.js ***!
  \****************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.v6 = exports.AddressError = exports.Address6 = exports.Address4 = void 0;\nvar ipv4_1 = __webpack_require__(/*! ./ipv4 */ \"(rsc)/./node_modules/ip-address/dist/ipv4.js\");\nObject.defineProperty(exports, \"Address4\", ({ enumerable: true, get: function () { return ipv4_1.Address4; } }));\nvar ipv6_1 = __webpack_require__(/*! ./ipv6 */ \"(rsc)/./node_modules/ip-address/dist/ipv6.js\");\nObject.defineProperty(exports, \"Address6\", ({ enumerable: true, get: function () { return ipv6_1.Address6; } }));\nvar address_error_1 = __webpack_require__(/*! ./address-error */ \"(rsc)/./node_modules/ip-address/dist/address-error.js\");\nObject.defineProperty(exports, \"AddressError\", ({ enumerable: true, get: function () { return address_error_1.AddressError; } }));\nconst helpers = __importStar(__webpack_require__(/*! ./v6/helpers */ \"(rsc)/./node_modules/ip-address/dist/v6/helpers.js\"));\nexports.v6 = { helpers };\n//# sourceMappingURL=ip-address.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaXAtYWRkcmVzcy9kaXN0L2lwLWFkZHJlc3MuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsb0NBQW9DO0FBQ25EO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLDBDQUEwQyw0QkFBNEI7QUFDdEUsQ0FBQztBQUNEO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELFVBQVUsR0FBRyxvQkFBb0IsR0FBRyxnQkFBZ0IsR0FBRyxnQkFBZ0I7QUFDdkUsYUFBYSxtQkFBTyxDQUFDLDREQUFRO0FBQzdCLDRDQUEyQyxFQUFFLHFDQUFxQywyQkFBMkIsRUFBQztBQUM5RyxhQUFhLG1CQUFPLENBQUMsNERBQVE7QUFDN0IsNENBQTJDLEVBQUUscUNBQXFDLDJCQUEyQixFQUFDO0FBQzlHLHNCQUFzQixtQkFBTyxDQUFDLDhFQUFpQjtBQUMvQyxnREFBK0MsRUFBRSxxQ0FBcUMsd0NBQXdDLEVBQUM7QUFDL0gsNkJBQTZCLG1CQUFPLENBQUMsd0VBQWM7QUFDbkQsVUFBVSxLQUFLO0FBQ2YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9tZXJjaGFudGFpLWFkbWluLy4vbm9kZV9tb2R1bGVzL2lwLWFkZHJlc3MvZGlzdC9pcC1hZGRyZXNzLmpzPzdmOTAiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IobSwgayk7XG4gICAgaWYgKCFkZXNjIHx8IChcImdldFwiIGluIGRlc2MgPyAhbS5fX2VzTW9kdWxlIDogZGVzYy53cml0YWJsZSB8fCBkZXNjLmNvbmZpZ3VyYWJsZSkpIHtcbiAgICAgIGRlc2MgPSB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH07XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgZGVzYyk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fc2V0TW9kdWxlRGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19zZXRNb2R1bGVEZWZhdWx0KSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCB2KSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIFwiZGVmYXVsdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2IH0pO1xufSkgOiBmdW5jdGlvbihvLCB2KSB7XG4gICAgb1tcImRlZmF1bHRcIl0gPSB2O1xufSk7XG52YXIgX19pbXBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydFN0YXIpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoayAhPT0gXCJkZWZhdWx0XCIgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIF9fY3JlYXRlQmluZGluZyhyZXN1bHQsIG1vZCwgayk7XG4gICAgX19zZXRNb2R1bGVEZWZhdWx0KHJlc3VsdCwgbW9kKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMudjYgPSBleHBvcnRzLkFkZHJlc3NFcnJvciA9IGV4cG9ydHMuQWRkcmVzczYgPSBleHBvcnRzLkFkZHJlc3M0ID0gdm9pZCAwO1xudmFyIGlwdjRfMSA9IHJlcXVpcmUoXCIuL2lwdjRcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJBZGRyZXNzNFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaXB2NF8xLkFkZHJlc3M0OyB9IH0pO1xudmFyIGlwdjZfMSA9IHJlcXVpcmUoXCIuL2lwdjZcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJBZGRyZXNzNlwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaXB2Nl8xLkFkZHJlc3M2OyB9IH0pO1xudmFyIGFkZHJlc3NfZXJyb3JfMSA9IHJlcXVpcmUoXCIuL2FkZHJlc3MtZXJyb3JcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJBZGRyZXNzRXJyb3JcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGFkZHJlc3NfZXJyb3JfMS5BZGRyZXNzRXJyb3I7IH0gfSk7XG5jb25zdCBoZWxwZXJzID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCIuL3Y2L2hlbHBlcnNcIikpO1xuZXhwb3J0cy52NiA9IHsgaGVscGVycyB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aXAtYWRkcmVzcy5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ip-address/dist/ip-address.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ip-address/dist/ipv4.js":
/*!**********************************************!*\
  !*** ./node_modules/ip-address/dist/ipv4.js ***!
  \**********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\n/* eslint-disable no-param-reassign */\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Address4 = void 0;\nconst common = __importStar(__webpack_require__(/*! ./common */ \"(rsc)/./node_modules/ip-address/dist/common.js\"));\nconst constants = __importStar(__webpack_require__(/*! ./v4/constants */ \"(rsc)/./node_modules/ip-address/dist/v4/constants.js\"));\nconst address_error_1 = __webpack_require__(/*! ./address-error */ \"(rsc)/./node_modules/ip-address/dist/address-error.js\");\n/**\n * Represents an IPv4 address\n * @class Address4\n * @param {string} address - An IPv4 address string\n */\nclass Address4 {\n    constructor(address) {\n        this.groups = constants.GROUPS;\n        this.parsedAddress = [];\n        this.parsedSubnet = '';\n        this.subnet = '/32';\n        this.subnetMask = 32;\n        this.v4 = true;\n        /**\n         * Returns true if the address is correct, false otherwise\n         * @memberof Address4\n         * @instance\n         * @returns {Boolean}\n         */\n        this.isCorrect = common.isCorrect(constants.BITS);\n        /**\n         * Returns true if the given address is in the subnet of the current address\n         * @memberof Address4\n         * @instance\n         * @returns {boolean}\n         */\n        this.isInSubnet = common.isInSubnet;\n        this.address = address;\n        const subnet = constants.RE_SUBNET_STRING.exec(address);\n        if (subnet) {\n            this.parsedSubnet = subnet[0].replace('/', '');\n            this.subnetMask = parseInt(this.parsedSubnet, 10);\n            this.subnet = `/${this.subnetMask}`;\n            if (this.subnetMask < 0 || this.subnetMask > constants.BITS) {\n                throw new address_error_1.AddressError('Invalid subnet mask.');\n            }\n            address = address.replace(constants.RE_SUBNET_STRING, '');\n        }\n        this.addressMinusSuffix = address;\n        this.parsedAddress = this.parse(address);\n    }\n    static isValid(address) {\n        try {\n            // eslint-disable-next-line no-new\n            new Address4(address);\n            return true;\n        }\n        catch (e) {\n            return false;\n        }\n    }\n    /*\n     * Parses a v4 address\n     */\n    parse(address) {\n        const groups = address.split('.');\n        if (!address.match(constants.RE_ADDRESS)) {\n            throw new address_error_1.AddressError('Invalid IPv4 address.');\n        }\n        return groups;\n    }\n    /**\n     * Returns the correct form of an address\n     * @memberof Address4\n     * @instance\n     * @returns {String}\n     */\n    correctForm() {\n        return this.parsedAddress.map((part) => parseInt(part, 10)).join('.');\n    }\n    /**\n     * Converts a hex string to an IPv4 address object\n     * @memberof Address4\n     * @static\n     * @param {string} hex - a hex string to convert\n     * @returns {Address4}\n     */\n    static fromHex(hex) {\n        const padded = hex.replace(/:/g, '').padStart(8, '0');\n        const groups = [];\n        let i;\n        for (i = 0; i < 8; i += 2) {\n            const h = padded.slice(i, i + 2);\n            groups.push(parseInt(h, 16));\n        }\n        return new Address4(groups.join('.'));\n    }\n    /**\n     * Converts an integer into a IPv4 address object\n     * @memberof Address4\n     * @static\n     * @param {integer} integer - a number to convert\n     * @returns {Address4}\n     */\n    static fromInteger(integer) {\n        return Address4.fromHex(integer.toString(16));\n    }\n    /**\n     * Return an address from in-addr.arpa form\n     * @memberof Address4\n     * @static\n     * @param {string} arpaFormAddress - an 'in-addr.arpa' form ipv4 address\n     * @returns {Adress4}\n     * @example\n     * var address = Address4.fromArpa(42.2.0.192.in-addr.arpa.)\n     * address.correctForm(); // '192.0.2.42'\n     */\n    static fromArpa(arpaFormAddress) {\n        // remove ending \".in-addr.arpa.\" or just \".\"\n        const leader = arpaFormAddress.replace(/(\\.in-addr\\.arpa)?\\.$/, '');\n        const address = leader.split('.').reverse().join('.');\n        return new Address4(address);\n    }\n    /**\n     * Converts an IPv4 address object to a hex string\n     * @memberof Address4\n     * @instance\n     * @returns {String}\n     */\n    toHex() {\n        return this.parsedAddress.map((part) => common.stringToPaddedHex(part)).join(':');\n    }\n    /**\n     * Converts an IPv4 address object to an array of bytes\n     * @memberof Address4\n     * @instance\n     * @returns {Array}\n     */\n    toArray() {\n        return this.parsedAddress.map((part) => parseInt(part, 10));\n    }\n    /**\n     * Converts an IPv4 address object to an IPv6 address group\n     * @memberof Address4\n     * @instance\n     * @returns {String}\n     */\n    toGroup6() {\n        const output = [];\n        let i;\n        for (i = 0; i < constants.GROUPS; i += 2) {\n            output.push(`${common.stringToPaddedHex(this.parsedAddress[i])}${common.stringToPaddedHex(this.parsedAddress[i + 1])}`);\n        }\n        return output.join(':');\n    }\n    /**\n     * Returns the address as a `bigint`\n     * @memberof Address4\n     * @instance\n     * @returns {bigint}\n     */\n    bigInt() {\n        return BigInt(`0x${this.parsedAddress.map((n) => common.stringToPaddedHex(n)).join('')}`);\n    }\n    /**\n     * Helper function getting start address.\n     * @memberof Address4\n     * @instance\n     * @returns {bigint}\n     */\n    _startAddress() {\n        return BigInt(`0b${this.mask() + '0'.repeat(constants.BITS - this.subnetMask)}`);\n    }\n    /**\n     * The first address in the range given by this address' subnet.\n     * Often referred to as the Network Address.\n     * @memberof Address4\n     * @instance\n     * @returns {Address4}\n     */\n    startAddress() {\n        return Address4.fromBigInt(this._startAddress());\n    }\n    /**\n     * The first host address in the range given by this address's subnet ie\n     * the first address after the Network Address\n     * @memberof Address4\n     * @instance\n     * @returns {Address4}\n     */\n    startAddressExclusive() {\n        const adjust = BigInt('1');\n        return Address4.fromBigInt(this._startAddress() + adjust);\n    }\n    /**\n     * Helper function getting end address.\n     * @memberof Address4\n     * @instance\n     * @returns {bigint}\n     */\n    _endAddress() {\n        return BigInt(`0b${this.mask() + '1'.repeat(constants.BITS - this.subnetMask)}`);\n    }\n    /**\n     * The last address in the range given by this address' subnet\n     * Often referred to as the Broadcast\n     * @memberof Address4\n     * @instance\n     * @returns {Address4}\n     */\n    endAddress() {\n        return Address4.fromBigInt(this._endAddress());\n    }\n    /**\n     * The last host address in the range given by this address's subnet ie\n     * the last address prior to the Broadcast Address\n     * @memberof Address4\n     * @instance\n     * @returns {Address4}\n     */\n    endAddressExclusive() {\n        const adjust = BigInt('1');\n        return Address4.fromBigInt(this._endAddress() - adjust);\n    }\n    /**\n     * Converts a BigInt to a v4 address object\n     * @memberof Address4\n     * @static\n     * @param {bigint} bigInt - a BigInt to convert\n     * @returns {Address4}\n     */\n    static fromBigInt(bigInt) {\n        return Address4.fromHex(bigInt.toString(16));\n    }\n    /**\n     * Convert a byte array to an Address4 object\n     * @memberof Address4\n     * @static\n     * @param {Array<number>} bytes - an array of 4 bytes (0-255)\n     * @returns {Address4}\n     */\n    static fromByteArray(bytes) {\n        if (bytes.length !== 4) {\n            throw new address_error_1.AddressError('IPv4 addresses require exactly 4 bytes');\n        }\n        // Validate that all bytes are within valid range (0-255)\n        for (let i = 0; i < bytes.length; i++) {\n            if (!Number.isInteger(bytes[i]) || bytes[i] < 0 || bytes[i] > 255) {\n                throw new address_error_1.AddressError('All bytes must be integers between 0 and 255');\n            }\n        }\n        return this.fromUnsignedByteArray(bytes);\n    }\n    /**\n     * Convert an unsigned byte array to an Address4 object\n     * @memberof Address4\n     * @static\n     * @param {Array<number>} bytes - an array of 4 unsigned bytes (0-255)\n     * @returns {Address4}\n     */\n    static fromUnsignedByteArray(bytes) {\n        if (bytes.length !== 4) {\n            throw new address_error_1.AddressError('IPv4 addresses require exactly 4 bytes');\n        }\n        const address = bytes.join('.');\n        return new Address4(address);\n    }\n    /**\n     * Returns the first n bits of the address, defaulting to the\n     * subnet mask\n     * @memberof Address4\n     * @instance\n     * @returns {String}\n     */\n    mask(mask) {\n        if (mask === undefined) {\n            mask = this.subnetMask;\n        }\n        return this.getBitsBase2(0, mask);\n    }\n    /**\n     * Returns the bits in the given range as a base-2 string\n     * @memberof Address4\n     * @instance\n     * @returns {string}\n     */\n    getBitsBase2(start, end) {\n        return this.binaryZeroPad().slice(start, end);\n    }\n    /**\n     * Return the reversed ip6.arpa form of the address\n     * @memberof Address4\n     * @param {Object} options\n     * @param {boolean} options.omitSuffix - omit the \"in-addr.arpa\" suffix\n     * @instance\n     * @returns {String}\n     */\n    reverseForm(options) {\n        if (!options) {\n            options = {};\n        }\n        const reversed = this.correctForm().split('.').reverse().join('.');\n        if (options.omitSuffix) {\n            return reversed;\n        }\n        return `${reversed}.in-addr.arpa.`;\n    }\n    /**\n     * Returns true if the given address is a multicast address\n     * @memberof Address4\n     * @instance\n     * @returns {boolean}\n     */\n    isMulticast() {\n        return this.isInSubnet(new Address4('224.0.0.0/4'));\n    }\n    /**\n     * Returns a zero-padded base-2 string representation of the address\n     * @memberof Address4\n     * @instance\n     * @returns {string}\n     */\n    binaryZeroPad() {\n        return this.bigInt().toString(2).padStart(constants.BITS, '0');\n    }\n    /**\n     * Groups an IPv4 address for inclusion at the end of an IPv6 address\n     * @returns {String}\n     */\n    groupForV6() {\n        const segments = this.parsedAddress;\n        return this.address.replace(constants.RE_ADDRESS, `<span class=\"hover-group group-v4 group-6\">${segments\n            .slice(0, 2)\n            .join('.')}</span>.<span class=\"hover-group group-v4 group-7\">${segments\n            .slice(2, 4)\n            .join('.')}</span>`);\n    }\n}\nexports.Address4 = Address4;\n//# sourceMappingURL=ipv4.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaXAtYWRkcmVzcy9kaXN0L2lwdjQuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxvQ0FBb0M7QUFDbkQ7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsMENBQTBDLDRCQUE0QjtBQUN0RSxDQUFDO0FBQ0Q7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsZ0JBQWdCO0FBQ2hCLDRCQUE0QixtQkFBTyxDQUFDLGdFQUFVO0FBQzlDLCtCQUErQixtQkFBTyxDQUFDLDRFQUFnQjtBQUN2RCx3QkFBd0IsbUJBQU8sQ0FBQyw4RUFBaUI7QUFDakQ7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixnQkFBZ0I7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLE9BQU87QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHNCQUFzQjtBQUMxQywyQkFBMkIsZ0RBQWdELEVBQUUsb0RBQW9EO0FBQ2pJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSwyQkFBMkIsb0VBQW9FO0FBQy9GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLDJCQUEyQiwyREFBMkQ7QUFDdEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLDJCQUEyQiwyREFBMkQ7QUFDdEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGVBQWU7QUFDOUIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixrQkFBa0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGVBQWU7QUFDOUIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxTQUFTO0FBQ3hCO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixTQUFTO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0Esd0dBQXdHO0FBQ3hHO0FBQ0EsdUJBQXVCLHFEQUFxRDtBQUM1RTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbWVyY2hhbnRhaS1hZG1pbi8uL25vZGVfbW9kdWxlcy9pcC1hZGRyZXNzL2Rpc3QvaXB2NC5qcz9kYjI1Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLyogZXNsaW50LWRpc2FibGUgbm8tcGFyYW0tcmVhc3NpZ24gKi9cbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcbiAgICBpZiAoIWRlc2MgfHwgKFwiZ2V0XCIgaW4gZGVzYyA/ICFtLl9fZXNNb2R1bGUgOiBkZXNjLndyaXRhYmxlIHx8IGRlc2MuY29uZmlndXJhYmxlKSkge1xuICAgICAgZGVzYyA9IHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCBkZXNjKTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19zZXRNb2R1bGVEZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX3NldE1vZHVsZURlZmF1bHQpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgXCJkZWZhdWx0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHYgfSk7XG59KSA6IGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBvW1wiZGVmYXVsdFwiXSA9IHY7XG59KTtcbnZhciBfX2ltcG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0U3RhcikgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChrICE9PSBcImRlZmF1bHRcIiAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgX19jcmVhdGVCaW5kaW5nKHJlc3VsdCwgbW9kLCBrKTtcbiAgICBfX3NldE1vZHVsZURlZmF1bHQocmVzdWx0LCBtb2QpO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5BZGRyZXNzNCA9IHZvaWQgMDtcbmNvbnN0IGNvbW1vbiA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwiLi9jb21tb25cIikpO1xuY29uc3QgY29uc3RhbnRzID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCIuL3Y0L2NvbnN0YW50c1wiKSk7XG5jb25zdCBhZGRyZXNzX2Vycm9yXzEgPSByZXF1aXJlKFwiLi9hZGRyZXNzLWVycm9yXCIpO1xuLyoqXG4gKiBSZXByZXNlbnRzIGFuIElQdjQgYWRkcmVzc1xuICogQGNsYXNzIEFkZHJlc3M0XG4gKiBAcGFyYW0ge3N0cmluZ30gYWRkcmVzcyAtIEFuIElQdjQgYWRkcmVzcyBzdHJpbmdcbiAqL1xuY2xhc3MgQWRkcmVzczQge1xuICAgIGNvbnN0cnVjdG9yKGFkZHJlc3MpIHtcbiAgICAgICAgdGhpcy5ncm91cHMgPSBjb25zdGFudHMuR1JPVVBTO1xuICAgICAgICB0aGlzLnBhcnNlZEFkZHJlc3MgPSBbXTtcbiAgICAgICAgdGhpcy5wYXJzZWRTdWJuZXQgPSAnJztcbiAgICAgICAgdGhpcy5zdWJuZXQgPSAnLzMyJztcbiAgICAgICAgdGhpcy5zdWJuZXRNYXNrID0gMzI7XG4gICAgICAgIHRoaXMudjQgPSB0cnVlO1xuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJucyB0cnVlIGlmIHRoZSBhZGRyZXNzIGlzIGNvcnJlY3QsIGZhbHNlIG90aGVyd2lzZVxuICAgICAgICAgKiBAbWVtYmVyb2YgQWRkcmVzczRcbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqIEByZXR1cm5zIHtCb29sZWFufVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5pc0NvcnJlY3QgPSBjb21tb24uaXNDb3JyZWN0KGNvbnN0YW50cy5CSVRTKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW4gYWRkcmVzcyBpcyBpbiB0aGUgc3VibmV0IG9mIHRoZSBjdXJyZW50IGFkZHJlc3NcbiAgICAgICAgICogQG1lbWJlcm9mIEFkZHJlc3M0XG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuaXNJblN1Ym5ldCA9IGNvbW1vbi5pc0luU3VibmV0O1xuICAgICAgICB0aGlzLmFkZHJlc3MgPSBhZGRyZXNzO1xuICAgICAgICBjb25zdCBzdWJuZXQgPSBjb25zdGFudHMuUkVfU1VCTkVUX1NUUklORy5leGVjKGFkZHJlc3MpO1xuICAgICAgICBpZiAoc3VibmV0KSB7XG4gICAgICAgICAgICB0aGlzLnBhcnNlZFN1Ym5ldCA9IHN1Ym5ldFswXS5yZXBsYWNlKCcvJywgJycpO1xuICAgICAgICAgICAgdGhpcy5zdWJuZXRNYXNrID0gcGFyc2VJbnQodGhpcy5wYXJzZWRTdWJuZXQsIDEwKTtcbiAgICAgICAgICAgIHRoaXMuc3VibmV0ID0gYC8ke3RoaXMuc3VibmV0TWFza31gO1xuICAgICAgICAgICAgaWYgKHRoaXMuc3VibmV0TWFzayA8IDAgfHwgdGhpcy5zdWJuZXRNYXNrID4gY29uc3RhbnRzLkJJVFMpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgYWRkcmVzc19lcnJvcl8xLkFkZHJlc3NFcnJvcignSW52YWxpZCBzdWJuZXQgbWFzay4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFkZHJlc3MgPSBhZGRyZXNzLnJlcGxhY2UoY29uc3RhbnRzLlJFX1NVQk5FVF9TVFJJTkcsICcnKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmFkZHJlc3NNaW51c1N1ZmZpeCA9IGFkZHJlc3M7XG4gICAgICAgIHRoaXMucGFyc2VkQWRkcmVzcyA9IHRoaXMucGFyc2UoYWRkcmVzcyk7XG4gICAgfVxuICAgIHN0YXRpYyBpc1ZhbGlkKGFkZHJlc3MpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1uZXdcbiAgICAgICAgICAgIG5ldyBBZGRyZXNzNChhZGRyZXNzKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLypcbiAgICAgKiBQYXJzZXMgYSB2NCBhZGRyZXNzXG4gICAgICovXG4gICAgcGFyc2UoYWRkcmVzcykge1xuICAgICAgICBjb25zdCBncm91cHMgPSBhZGRyZXNzLnNwbGl0KCcuJyk7XG4gICAgICAgIGlmICghYWRkcmVzcy5tYXRjaChjb25zdGFudHMuUkVfQUREUkVTUykpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBhZGRyZXNzX2Vycm9yXzEuQWRkcmVzc0Vycm9yKCdJbnZhbGlkIElQdjQgYWRkcmVzcy4nKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZ3JvdXBzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBjb3JyZWN0IGZvcm0gb2YgYW4gYWRkcmVzc1xuICAgICAqIEBtZW1iZXJvZiBBZGRyZXNzNFxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEByZXR1cm5zIHtTdHJpbmd9XG4gICAgICovXG4gICAgY29ycmVjdEZvcm0oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlZEFkZHJlc3MubWFwKChwYXJ0KSA9PiBwYXJzZUludChwYXJ0LCAxMCkpLmpvaW4oJy4nKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYSBoZXggc3RyaW5nIHRvIGFuIElQdjQgYWRkcmVzcyBvYmplY3RcbiAgICAgKiBAbWVtYmVyb2YgQWRkcmVzczRcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGhleCAtIGEgaGV4IHN0cmluZyB0byBjb252ZXJ0XG4gICAgICogQHJldHVybnMge0FkZHJlc3M0fVxuICAgICAqL1xuICAgIHN0YXRpYyBmcm9tSGV4KGhleCkge1xuICAgICAgICBjb25zdCBwYWRkZWQgPSBoZXgucmVwbGFjZSgvOi9nLCAnJykucGFkU3RhcnQoOCwgJzAnKTtcbiAgICAgICAgY29uc3QgZ3JvdXBzID0gW107XG4gICAgICAgIGxldCBpO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgODsgaSArPSAyKSB7XG4gICAgICAgICAgICBjb25zdCBoID0gcGFkZGVkLnNsaWNlKGksIGkgKyAyKTtcbiAgICAgICAgICAgIGdyb3Vwcy5wdXNoKHBhcnNlSW50KGgsIDE2KSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBBZGRyZXNzNChncm91cHMuam9pbignLicpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYW4gaW50ZWdlciBpbnRvIGEgSVB2NCBhZGRyZXNzIG9iamVjdFxuICAgICAqIEBtZW1iZXJvZiBBZGRyZXNzNFxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAcGFyYW0ge2ludGVnZXJ9IGludGVnZXIgLSBhIG51bWJlciB0byBjb252ZXJ0XG4gICAgICogQHJldHVybnMge0FkZHJlc3M0fVxuICAgICAqL1xuICAgIHN0YXRpYyBmcm9tSW50ZWdlcihpbnRlZ2VyKSB7XG4gICAgICAgIHJldHVybiBBZGRyZXNzNC5mcm9tSGV4KGludGVnZXIudG9TdHJpbmcoMTYpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJuIGFuIGFkZHJlc3MgZnJvbSBpbi1hZGRyLmFycGEgZm9ybVxuICAgICAqIEBtZW1iZXJvZiBBZGRyZXNzNFxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gYXJwYUZvcm1BZGRyZXNzIC0gYW4gJ2luLWFkZHIuYXJwYScgZm9ybSBpcHY0IGFkZHJlc3NcbiAgICAgKiBAcmV0dXJucyB7QWRyZXNzNH1cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIHZhciBhZGRyZXNzID0gQWRkcmVzczQuZnJvbUFycGEoNDIuMi4wLjE5Mi5pbi1hZGRyLmFycGEuKVxuICAgICAqIGFkZHJlc3MuY29ycmVjdEZvcm0oKTsgLy8gJzE5Mi4wLjIuNDInXG4gICAgICovXG4gICAgc3RhdGljIGZyb21BcnBhKGFycGFGb3JtQWRkcmVzcykge1xuICAgICAgICAvLyByZW1vdmUgZW5kaW5nIFwiLmluLWFkZHIuYXJwYS5cIiBvciBqdXN0IFwiLlwiXG4gICAgICAgIGNvbnN0IGxlYWRlciA9IGFycGFGb3JtQWRkcmVzcy5yZXBsYWNlKC8oXFwuaW4tYWRkclxcLmFycGEpP1xcLiQvLCAnJyk7XG4gICAgICAgIGNvbnN0IGFkZHJlc3MgPSBsZWFkZXIuc3BsaXQoJy4nKS5yZXZlcnNlKCkuam9pbignLicpO1xuICAgICAgICByZXR1cm4gbmV3IEFkZHJlc3M0KGFkZHJlc3MpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBhbiBJUHY0IGFkZHJlc3Mgb2JqZWN0IHRvIGEgaGV4IHN0cmluZ1xuICAgICAqIEBtZW1iZXJvZiBBZGRyZXNzNFxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEByZXR1cm5zIHtTdHJpbmd9XG4gICAgICovXG4gICAgdG9IZXgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlZEFkZHJlc3MubWFwKChwYXJ0KSA9PiBjb21tb24uc3RyaW5nVG9QYWRkZWRIZXgocGFydCkpLmpvaW4oJzonKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYW4gSVB2NCBhZGRyZXNzIG9iamVjdCB0byBhbiBhcnJheSBvZiBieXRlc1xuICAgICAqIEBtZW1iZXJvZiBBZGRyZXNzNFxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEByZXR1cm5zIHtBcnJheX1cbiAgICAgKi9cbiAgICB0b0FycmF5KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZWRBZGRyZXNzLm1hcCgocGFydCkgPT4gcGFyc2VJbnQocGFydCwgMTApKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYW4gSVB2NCBhZGRyZXNzIG9iamVjdCB0byBhbiBJUHY2IGFkZHJlc3MgZ3JvdXBcbiAgICAgKiBAbWVtYmVyb2YgQWRkcmVzczRcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfVxuICAgICAqL1xuICAgIHRvR3JvdXA2KCkge1xuICAgICAgICBjb25zdCBvdXRwdXQgPSBbXTtcbiAgICAgICAgbGV0IGk7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBjb25zdGFudHMuR1JPVVBTOyBpICs9IDIpIHtcbiAgICAgICAgICAgIG91dHB1dC5wdXNoKGAke2NvbW1vbi5zdHJpbmdUb1BhZGRlZEhleCh0aGlzLnBhcnNlZEFkZHJlc3NbaV0pfSR7Y29tbW9uLnN0cmluZ1RvUGFkZGVkSGV4KHRoaXMucGFyc2VkQWRkcmVzc1tpICsgMV0pfWApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvdXRwdXQuam9pbignOicpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBhZGRyZXNzIGFzIGEgYGJpZ2ludGBcbiAgICAgKiBAbWVtYmVyb2YgQWRkcmVzczRcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAcmV0dXJucyB7YmlnaW50fVxuICAgICAqL1xuICAgIGJpZ0ludCgpIHtcbiAgICAgICAgcmV0dXJuIEJpZ0ludChgMHgke3RoaXMucGFyc2VkQWRkcmVzcy5tYXAoKG4pID0+IGNvbW1vbi5zdHJpbmdUb1BhZGRlZEhleChuKSkuam9pbignJyl9YCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEhlbHBlciBmdW5jdGlvbiBnZXR0aW5nIHN0YXJ0IGFkZHJlc3MuXG4gICAgICogQG1lbWJlcm9mIEFkZHJlc3M0XG4gICAgICogQGluc3RhbmNlXG4gICAgICogQHJldHVybnMge2JpZ2ludH1cbiAgICAgKi9cbiAgICBfc3RhcnRBZGRyZXNzKCkge1xuICAgICAgICByZXR1cm4gQmlnSW50KGAwYiR7dGhpcy5tYXNrKCkgKyAnMCcucmVwZWF0KGNvbnN0YW50cy5CSVRTIC0gdGhpcy5zdWJuZXRNYXNrKX1gKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIGZpcnN0IGFkZHJlc3MgaW4gdGhlIHJhbmdlIGdpdmVuIGJ5IHRoaXMgYWRkcmVzcycgc3VibmV0LlxuICAgICAqIE9mdGVuIHJlZmVycmVkIHRvIGFzIHRoZSBOZXR3b3JrIEFkZHJlc3MuXG4gICAgICogQG1lbWJlcm9mIEFkZHJlc3M0XG4gICAgICogQGluc3RhbmNlXG4gICAgICogQHJldHVybnMge0FkZHJlc3M0fVxuICAgICAqL1xuICAgIHN0YXJ0QWRkcmVzcygpIHtcbiAgICAgICAgcmV0dXJuIEFkZHJlc3M0LmZyb21CaWdJbnQodGhpcy5fc3RhcnRBZGRyZXNzKCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgZmlyc3QgaG9zdCBhZGRyZXNzIGluIHRoZSByYW5nZSBnaXZlbiBieSB0aGlzIGFkZHJlc3MncyBzdWJuZXQgaWVcbiAgICAgKiB0aGUgZmlyc3QgYWRkcmVzcyBhZnRlciB0aGUgTmV0d29yayBBZGRyZXNzXG4gICAgICogQG1lbWJlcm9mIEFkZHJlc3M0XG4gICAgICogQGluc3RhbmNlXG4gICAgICogQHJldHVybnMge0FkZHJlc3M0fVxuICAgICAqL1xuICAgIHN0YXJ0QWRkcmVzc0V4Y2x1c2l2ZSgpIHtcbiAgICAgICAgY29uc3QgYWRqdXN0ID0gQmlnSW50KCcxJyk7XG4gICAgICAgIHJldHVybiBBZGRyZXNzNC5mcm9tQmlnSW50KHRoaXMuX3N0YXJ0QWRkcmVzcygpICsgYWRqdXN0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSGVscGVyIGZ1bmN0aW9uIGdldHRpbmcgZW5kIGFkZHJlc3MuXG4gICAgICogQG1lbWJlcm9mIEFkZHJlc3M0XG4gICAgICogQGluc3RhbmNlXG4gICAgICogQHJldHVybnMge2JpZ2ludH1cbiAgICAgKi9cbiAgICBfZW5kQWRkcmVzcygpIHtcbiAgICAgICAgcmV0dXJuIEJpZ0ludChgMGIke3RoaXMubWFzaygpICsgJzEnLnJlcGVhdChjb25zdGFudHMuQklUUyAtIHRoaXMuc3VibmV0TWFzayl9YCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSBsYXN0IGFkZHJlc3MgaW4gdGhlIHJhbmdlIGdpdmVuIGJ5IHRoaXMgYWRkcmVzcycgc3VibmV0XG4gICAgICogT2Z0ZW4gcmVmZXJyZWQgdG8gYXMgdGhlIEJyb2FkY2FzdFxuICAgICAqIEBtZW1iZXJvZiBBZGRyZXNzNFxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEByZXR1cm5zIHtBZGRyZXNzNH1cbiAgICAgKi9cbiAgICBlbmRBZGRyZXNzKCkge1xuICAgICAgICByZXR1cm4gQWRkcmVzczQuZnJvbUJpZ0ludCh0aGlzLl9lbmRBZGRyZXNzKCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgbGFzdCBob3N0IGFkZHJlc3MgaW4gdGhlIHJhbmdlIGdpdmVuIGJ5IHRoaXMgYWRkcmVzcydzIHN1Ym5ldCBpZVxuICAgICAqIHRoZSBsYXN0IGFkZHJlc3MgcHJpb3IgdG8gdGhlIEJyb2FkY2FzdCBBZGRyZXNzXG4gICAgICogQG1lbWJlcm9mIEFkZHJlc3M0XG4gICAgICogQGluc3RhbmNlXG4gICAgICogQHJldHVybnMge0FkZHJlc3M0fVxuICAgICAqL1xuICAgIGVuZEFkZHJlc3NFeGNsdXNpdmUoKSB7XG4gICAgICAgIGNvbnN0IGFkanVzdCA9IEJpZ0ludCgnMScpO1xuICAgICAgICByZXR1cm4gQWRkcmVzczQuZnJvbUJpZ0ludCh0aGlzLl9lbmRBZGRyZXNzKCkgLSBhZGp1c3QpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBhIEJpZ0ludCB0byBhIHY0IGFkZHJlc3Mgb2JqZWN0XG4gICAgICogQG1lbWJlcm9mIEFkZHJlc3M0XG4gICAgICogQHN0YXRpY1xuICAgICAqIEBwYXJhbSB7YmlnaW50fSBiaWdJbnQgLSBhIEJpZ0ludCB0byBjb252ZXJ0XG4gICAgICogQHJldHVybnMge0FkZHJlc3M0fVxuICAgICAqL1xuICAgIHN0YXRpYyBmcm9tQmlnSW50KGJpZ0ludCkge1xuICAgICAgICByZXR1cm4gQWRkcmVzczQuZnJvbUhleChiaWdJbnQudG9TdHJpbmcoMTYpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29udmVydCBhIGJ5dGUgYXJyYXkgdG8gYW4gQWRkcmVzczQgb2JqZWN0XG4gICAgICogQG1lbWJlcm9mIEFkZHJlc3M0XG4gICAgICogQHN0YXRpY1xuICAgICAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gYnl0ZXMgLSBhbiBhcnJheSBvZiA0IGJ5dGVzICgwLTI1NSlcbiAgICAgKiBAcmV0dXJucyB7QWRkcmVzczR9XG4gICAgICovXG4gICAgc3RhdGljIGZyb21CeXRlQXJyYXkoYnl0ZXMpIHtcbiAgICAgICAgaWYgKGJ5dGVzLmxlbmd0aCAhPT0gNCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IGFkZHJlc3NfZXJyb3JfMS5BZGRyZXNzRXJyb3IoJ0lQdjQgYWRkcmVzc2VzIHJlcXVpcmUgZXhhY3RseSA0IGJ5dGVzJyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVmFsaWRhdGUgdGhhdCBhbGwgYnl0ZXMgYXJlIHdpdGhpbiB2YWxpZCByYW5nZSAoMC0yNTUpXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmICghTnVtYmVyLmlzSW50ZWdlcihieXRlc1tpXSkgfHwgYnl0ZXNbaV0gPCAwIHx8IGJ5dGVzW2ldID4gMjU1KSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IGFkZHJlc3NfZXJyb3JfMS5BZGRyZXNzRXJyb3IoJ0FsbCBieXRlcyBtdXN0IGJlIGludGVnZXJzIGJldHdlZW4gMCBhbmQgMjU1Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuZnJvbVVuc2lnbmVkQnl0ZUFycmF5KGJ5dGVzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29udmVydCBhbiB1bnNpZ25lZCBieXRlIGFycmF5IHRvIGFuIEFkZHJlc3M0IG9iamVjdFxuICAgICAqIEBtZW1iZXJvZiBBZGRyZXNzNFxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IGJ5dGVzIC0gYW4gYXJyYXkgb2YgNCB1bnNpZ25lZCBieXRlcyAoMC0yNTUpXG4gICAgICogQHJldHVybnMge0FkZHJlc3M0fVxuICAgICAqL1xuICAgIHN0YXRpYyBmcm9tVW5zaWduZWRCeXRlQXJyYXkoYnl0ZXMpIHtcbiAgICAgICAgaWYgKGJ5dGVzLmxlbmd0aCAhPT0gNCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IGFkZHJlc3NfZXJyb3JfMS5BZGRyZXNzRXJyb3IoJ0lQdjQgYWRkcmVzc2VzIHJlcXVpcmUgZXhhY3RseSA0IGJ5dGVzJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYWRkcmVzcyA9IGJ5dGVzLmpvaW4oJy4nKTtcbiAgICAgICAgcmV0dXJuIG5ldyBBZGRyZXNzNChhZGRyZXNzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgZmlyc3QgbiBiaXRzIG9mIHRoZSBhZGRyZXNzLCBkZWZhdWx0aW5nIHRvIHRoZVxuICAgICAqIHN1Ym5ldCBtYXNrXG4gICAgICogQG1lbWJlcm9mIEFkZHJlc3M0XG4gICAgICogQGluc3RhbmNlXG4gICAgICogQHJldHVybnMge1N0cmluZ31cbiAgICAgKi9cbiAgICBtYXNrKG1hc2spIHtcbiAgICAgICAgaWYgKG1hc2sgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgbWFzayA9IHRoaXMuc3VibmV0TWFzaztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5nZXRCaXRzQmFzZTIoMCwgbWFzayk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGJpdHMgaW4gdGhlIGdpdmVuIHJhbmdlIGFzIGEgYmFzZS0yIHN0cmluZ1xuICAgICAqIEBtZW1iZXJvZiBBZGRyZXNzNFxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAgICovXG4gICAgZ2V0Qml0c0Jhc2UyKHN0YXJ0LCBlbmQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYmluYXJ5WmVyb1BhZCgpLnNsaWNlKHN0YXJ0LCBlbmQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gdGhlIHJldmVyc2VkIGlwNi5hcnBhIGZvcm0gb2YgdGhlIGFkZHJlc3NcbiAgICAgKiBAbWVtYmVyb2YgQWRkcmVzczRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gb3B0aW9ucy5vbWl0U3VmZml4IC0gb21pdCB0aGUgXCJpbi1hZGRyLmFycGFcIiBzdWZmaXhcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfVxuICAgICAqL1xuICAgIHJldmVyc2VGb3JtKG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKCFvcHRpb25zKSB7XG4gICAgICAgICAgICBvcHRpb25zID0ge307XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmV2ZXJzZWQgPSB0aGlzLmNvcnJlY3RGb3JtKCkuc3BsaXQoJy4nKS5yZXZlcnNlKCkuam9pbignLicpO1xuICAgICAgICBpZiAob3B0aW9ucy5vbWl0U3VmZml4KSB7XG4gICAgICAgICAgICByZXR1cm4gcmV2ZXJzZWQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGAke3JldmVyc2VkfS5pbi1hZGRyLmFycGEuYDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiBhZGRyZXNzIGlzIGEgbXVsdGljYXN0IGFkZHJlc3NcbiAgICAgKiBAbWVtYmVyb2YgQWRkcmVzczRcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBpc011bHRpY2FzdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNJblN1Ym5ldChuZXcgQWRkcmVzczQoJzIyNC4wLjAuMC80JykpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgemVyby1wYWRkZWQgYmFzZS0yIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgYWRkcmVzc1xuICAgICAqIEBtZW1iZXJvZiBBZGRyZXNzNFxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAgICovXG4gICAgYmluYXJ5WmVyb1BhZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYmlnSW50KCkudG9TdHJpbmcoMikucGFkU3RhcnQoY29uc3RhbnRzLkJJVFMsICcwJyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdyb3VwcyBhbiBJUHY0IGFkZHJlc3MgZm9yIGluY2x1c2lvbiBhdCB0aGUgZW5kIG9mIGFuIElQdjYgYWRkcmVzc1xuICAgICAqIEByZXR1cm5zIHtTdHJpbmd9XG4gICAgICovXG4gICAgZ3JvdXBGb3JWNigpIHtcbiAgICAgICAgY29uc3Qgc2VnbWVudHMgPSB0aGlzLnBhcnNlZEFkZHJlc3M7XG4gICAgICAgIHJldHVybiB0aGlzLmFkZHJlc3MucmVwbGFjZShjb25zdGFudHMuUkVfQUREUkVTUywgYDxzcGFuIGNsYXNzPVwiaG92ZXItZ3JvdXAgZ3JvdXAtdjQgZ3JvdXAtNlwiPiR7c2VnbWVudHNcbiAgICAgICAgICAgIC5zbGljZSgwLCAyKVxuICAgICAgICAgICAgLmpvaW4oJy4nKX08L3NwYW4+LjxzcGFuIGNsYXNzPVwiaG92ZXItZ3JvdXAgZ3JvdXAtdjQgZ3JvdXAtN1wiPiR7c2VnbWVudHNcbiAgICAgICAgICAgIC5zbGljZSgyLCA0KVxuICAgICAgICAgICAgLmpvaW4oJy4nKX08L3NwYW4+YCk7XG4gICAgfVxufVxuZXhwb3J0cy5BZGRyZXNzNCA9IEFkZHJlc3M0O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aXB2NC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ip-address/dist/ipv4.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ip-address/dist/ipv6.js":
/*!**********************************************!*\
  !*** ./node_modules/ip-address/dist/ipv6.js ***!
  \**********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\n/* eslint-disable prefer-destructuring */\n/* eslint-disable no-param-reassign */\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Address6 = void 0;\nconst common = __importStar(__webpack_require__(/*! ./common */ \"(rsc)/./node_modules/ip-address/dist/common.js\"));\nconst constants4 = __importStar(__webpack_require__(/*! ./v4/constants */ \"(rsc)/./node_modules/ip-address/dist/v4/constants.js\"));\nconst constants6 = __importStar(__webpack_require__(/*! ./v6/constants */ \"(rsc)/./node_modules/ip-address/dist/v6/constants.js\"));\nconst helpers = __importStar(__webpack_require__(/*! ./v6/helpers */ \"(rsc)/./node_modules/ip-address/dist/v6/helpers.js\"));\nconst ipv4_1 = __webpack_require__(/*! ./ipv4 */ \"(rsc)/./node_modules/ip-address/dist/ipv4.js\");\nconst regular_expressions_1 = __webpack_require__(/*! ./v6/regular-expressions */ \"(rsc)/./node_modules/ip-address/dist/v6/regular-expressions.js\");\nconst address_error_1 = __webpack_require__(/*! ./address-error */ \"(rsc)/./node_modules/ip-address/dist/address-error.js\");\nconst common_1 = __webpack_require__(/*! ./common */ \"(rsc)/./node_modules/ip-address/dist/common.js\");\nfunction assert(condition) {\n    if (!condition) {\n        throw new Error('Assertion failed.');\n    }\n}\nfunction addCommas(number) {\n    const r = /(\\d+)(\\d{3})/;\n    while (r.test(number)) {\n        number = number.replace(r, '$1,$2');\n    }\n    return number;\n}\nfunction spanLeadingZeroes4(n) {\n    n = n.replace(/^(0{1,})([1-9]+)$/, '<span class=\"parse-error\">$1</span>$2');\n    n = n.replace(/^(0{1,})(0)$/, '<span class=\"parse-error\">$1</span>$2');\n    return n;\n}\n/*\n * A helper function to compact an array\n */\nfunction compact(address, slice) {\n    const s1 = [];\n    const s2 = [];\n    let i;\n    for (i = 0; i < address.length; i++) {\n        if (i < slice[0]) {\n            s1.push(address[i]);\n        }\n        else if (i > slice[1]) {\n            s2.push(address[i]);\n        }\n    }\n    return s1.concat(['compact']).concat(s2);\n}\nfunction paddedHex(octet) {\n    return parseInt(octet, 16).toString(16).padStart(4, '0');\n}\nfunction unsignByte(b) {\n    // eslint-disable-next-line no-bitwise\n    return b & 0xff;\n}\n/**\n * Represents an IPv6 address\n * @class Address6\n * @param {string} address - An IPv6 address string\n * @param {number} [groups=8] - How many octets to parse\n * @example\n * var address = new Address6('2001::/32');\n */\nclass Address6 {\n    constructor(address, optionalGroups) {\n        this.addressMinusSuffix = '';\n        this.parsedSubnet = '';\n        this.subnet = '/128';\n        this.subnetMask = 128;\n        this.v4 = false;\n        this.zone = '';\n        // #region Attributes\n        /**\n         * Returns true if the given address is in the subnet of the current address\n         * @memberof Address6\n         * @instance\n         * @returns {boolean}\n         */\n        this.isInSubnet = common.isInSubnet;\n        /**\n         * Returns true if the address is correct, false otherwise\n         * @memberof Address6\n         * @instance\n         * @returns {boolean}\n         */\n        this.isCorrect = common.isCorrect(constants6.BITS);\n        if (optionalGroups === undefined) {\n            this.groups = constants6.GROUPS;\n        }\n        else {\n            this.groups = optionalGroups;\n        }\n        this.address = address;\n        const subnet = constants6.RE_SUBNET_STRING.exec(address);\n        if (subnet) {\n            this.parsedSubnet = subnet[0].replace('/', '');\n            this.subnetMask = parseInt(this.parsedSubnet, 10);\n            this.subnet = `/${this.subnetMask}`;\n            if (Number.isNaN(this.subnetMask) ||\n                this.subnetMask < 0 ||\n                this.subnetMask > constants6.BITS) {\n                throw new address_error_1.AddressError('Invalid subnet mask.');\n            }\n            address = address.replace(constants6.RE_SUBNET_STRING, '');\n        }\n        else if (/\\//.test(address)) {\n            throw new address_error_1.AddressError('Invalid subnet mask.');\n        }\n        const zone = constants6.RE_ZONE_STRING.exec(address);\n        if (zone) {\n            this.zone = zone[0];\n            address = address.replace(constants6.RE_ZONE_STRING, '');\n        }\n        this.addressMinusSuffix = address;\n        this.parsedAddress = this.parse(this.addressMinusSuffix);\n    }\n    static isValid(address) {\n        try {\n            // eslint-disable-next-line no-new\n            new Address6(address);\n            return true;\n        }\n        catch (e) {\n            return false;\n        }\n    }\n    /**\n     * Convert a BigInt to a v6 address object\n     * @memberof Address6\n     * @static\n     * @param {bigint} bigInt - a BigInt to convert\n     * @returns {Address6}\n     * @example\n     * var bigInt = BigInt('1000000000000');\n     * var address = Address6.fromBigInt(bigInt);\n     * address.correctForm(); // '::e8:d4a5:1000'\n     */\n    static fromBigInt(bigInt) {\n        const hex = bigInt.toString(16).padStart(32, '0');\n        const groups = [];\n        let i;\n        for (i = 0; i < constants6.GROUPS; i++) {\n            groups.push(hex.slice(i * 4, (i + 1) * 4));\n        }\n        return new Address6(groups.join(':'));\n    }\n    /**\n     * Convert a URL (with optional port number) to an address object\n     * @memberof Address6\n     * @static\n     * @param {string} url - a URL with optional port number\n     * @example\n     * var addressAndPort = Address6.fromURL('http://[ffff::]:8080/foo/');\n     * addressAndPort.address.correctForm(); // 'ffff::'\n     * addressAndPort.port; // 8080\n     */\n    static fromURL(url) {\n        let host;\n        let port = null;\n        let result;\n        // If we have brackets parse them and find a port\n        if (url.indexOf('[') !== -1 && url.indexOf(']:') !== -1) {\n            result = constants6.RE_URL_WITH_PORT.exec(url);\n            if (result === null) {\n                return {\n                    error: 'failed to parse address with port',\n                    address: null,\n                    port: null,\n                };\n            }\n            host = result[1];\n            port = result[2];\n            // If there's a URL extract the address\n        }\n        else if (url.indexOf('/') !== -1) {\n            // Remove the protocol prefix\n            url = url.replace(/^[a-z0-9]+:\\/\\//, '');\n            // Parse the address\n            result = constants6.RE_URL.exec(url);\n            if (result === null) {\n                return {\n                    error: 'failed to parse address from URL',\n                    address: null,\n                    port: null,\n                };\n            }\n            host = result[1];\n            // Otherwise just assign the URL to the host and let the library parse it\n        }\n        else {\n            host = url;\n        }\n        // If there's a port convert it to an integer\n        if (port) {\n            port = parseInt(port, 10);\n            // squelch out of range ports\n            if (port < 0 || port > 65536) {\n                port = null;\n            }\n        }\n        else {\n            // Standardize `undefined` to `null`\n            port = null;\n        }\n        return {\n            address: new Address6(host),\n            port,\n        };\n    }\n    /**\n     * Create an IPv6-mapped address given an IPv4 address\n     * @memberof Address6\n     * @static\n     * @param {string} address - An IPv4 address string\n     * @returns {Address6}\n     * @example\n     * var address = Address6.fromAddress4('192.168.0.1');\n     * address.correctForm(); // '::ffff:c0a8:1'\n     * address.to4in6(); // '::ffff:192.168.0.1'\n     */\n    static fromAddress4(address) {\n        const address4 = new ipv4_1.Address4(address);\n        const mask6 = constants6.BITS - (constants4.BITS - address4.subnetMask);\n        return new Address6(`::ffff:${address4.correctForm()}/${mask6}`);\n    }\n    /**\n     * Return an address from ip6.arpa form\n     * @memberof Address6\n     * @static\n     * @param {string} arpaFormAddress - an 'ip6.arpa' form address\n     * @returns {Adress6}\n     * @example\n     * var address = Address6.fromArpa(e.f.f.f.3.c.2.6.f.f.f.e.6.6.8.e.1.0.6.7.9.4.e.c.0.0.0.0.1.0.0.2.ip6.arpa.)\n     * address.correctForm(); // '2001:0:ce49:7601:e866:efff:62c3:fffe'\n     */\n    static fromArpa(arpaFormAddress) {\n        // remove ending \".ip6.arpa.\" or just \".\"\n        let address = arpaFormAddress.replace(/(\\.ip6\\.arpa)?\\.$/, '');\n        const semicolonAmount = 7;\n        // correct ip6.arpa form with ending removed will be 63 characters\n        if (address.length !== 63) {\n            throw new address_error_1.AddressError(\"Invalid 'ip6.arpa' form.\");\n        }\n        const parts = address.split('.').reverse();\n        for (let i = semicolonAmount; i > 0; i--) {\n            const insertIndex = i * 4;\n            parts.splice(insertIndex, 0, ':');\n        }\n        address = parts.join('');\n        return new Address6(address);\n    }\n    /**\n     * Return the Microsoft UNC transcription of the address\n     * @memberof Address6\n     * @instance\n     * @returns {String} the Microsoft UNC transcription of the address\n     */\n    microsoftTranscription() {\n        return `${this.correctForm().replace(/:/g, '-')}.ipv6-literal.net`;\n    }\n    /**\n     * Return the first n bits of the address, defaulting to the subnet mask\n     * @memberof Address6\n     * @instance\n     * @param {number} [mask=subnet] - the number of bits to mask\n     * @returns {String} the first n bits of the address as a string\n     */\n    mask(mask = this.subnetMask) {\n        return this.getBitsBase2(0, mask);\n    }\n    /**\n     * Return the number of possible subnets of a given size in the address\n     * @memberof Address6\n     * @instance\n     * @param {number} [subnetSize=128] - the subnet size\n     * @returns {String}\n     */\n    // TODO: probably useful to have a numeric version of this too\n    possibleSubnets(subnetSize = 128) {\n        const availableBits = constants6.BITS - this.subnetMask;\n        const subnetBits = Math.abs(subnetSize - constants6.BITS);\n        const subnetPowers = availableBits - subnetBits;\n        if (subnetPowers < 0) {\n            return '0';\n        }\n        return addCommas((BigInt('2') ** BigInt(subnetPowers)).toString(10));\n    }\n    /**\n     * Helper function getting start address.\n     * @memberof Address6\n     * @instance\n     * @returns {bigint}\n     */\n    _startAddress() {\n        return BigInt(`0b${this.mask() + '0'.repeat(constants6.BITS - this.subnetMask)}`);\n    }\n    /**\n     * The first address in the range given by this address' subnet\n     * Often referred to as the Network Address.\n     * @memberof Address6\n     * @instance\n     * @returns {Address6}\n     */\n    startAddress() {\n        return Address6.fromBigInt(this._startAddress());\n    }\n    /**\n     * The first host address in the range given by this address's subnet ie\n     * the first address after the Network Address\n     * @memberof Address6\n     * @instance\n     * @returns {Address6}\n     */\n    startAddressExclusive() {\n        const adjust = BigInt('1');\n        return Address6.fromBigInt(this._startAddress() + adjust);\n    }\n    /**\n     * Helper function getting end address.\n     * @memberof Address6\n     * @instance\n     * @returns {bigint}\n     */\n    _endAddress() {\n        return BigInt(`0b${this.mask() + '1'.repeat(constants6.BITS - this.subnetMask)}`);\n    }\n    /**\n     * The last address in the range given by this address' subnet\n     * Often referred to as the Broadcast\n     * @memberof Address6\n     * @instance\n     * @returns {Address6}\n     */\n    endAddress() {\n        return Address6.fromBigInt(this._endAddress());\n    }\n    /**\n     * The last host address in the range given by this address's subnet ie\n     * the last address prior to the Broadcast Address\n     * @memberof Address6\n     * @instance\n     * @returns {Address6}\n     */\n    endAddressExclusive() {\n        const adjust = BigInt('1');\n        return Address6.fromBigInt(this._endAddress() - adjust);\n    }\n    /**\n     * Return the scope of the address\n     * @memberof Address6\n     * @instance\n     * @returns {String}\n     */\n    getScope() {\n        let scope = constants6.SCOPES[parseInt(this.getBits(12, 16).toString(10), 10)];\n        if (this.getType() === 'Global unicast' && scope !== 'Link local') {\n            scope = 'Global';\n        }\n        return scope || 'Unknown';\n    }\n    /**\n     * Return the type of the address\n     * @memberof Address6\n     * @instance\n     * @returns {String}\n     */\n    getType() {\n        for (const subnet of Object.keys(constants6.TYPES)) {\n            if (this.isInSubnet(new Address6(subnet))) {\n                return constants6.TYPES[subnet];\n            }\n        }\n        return 'Global unicast';\n    }\n    /**\n     * Return the bits in the given range as a BigInt\n     * @memberof Address6\n     * @instance\n     * @returns {bigint}\n     */\n    getBits(start, end) {\n        return BigInt(`0b${this.getBitsBase2(start, end)}`);\n    }\n    /**\n     * Return the bits in the given range as a base-2 string\n     * @memberof Address6\n     * @instance\n     * @returns {String}\n     */\n    getBitsBase2(start, end) {\n        return this.binaryZeroPad().slice(start, end);\n    }\n    /**\n     * Return the bits in the given range as a base-16 string\n     * @memberof Address6\n     * @instance\n     * @returns {String}\n     */\n    getBitsBase16(start, end) {\n        const length = end - start;\n        if (length % 4 !== 0) {\n            throw new Error('Length of bits to retrieve must be divisible by four');\n        }\n        return this.getBits(start, end)\n            .toString(16)\n            .padStart(length / 4, '0');\n    }\n    /**\n     * Return the bits that are set past the subnet mask length\n     * @memberof Address6\n     * @instance\n     * @returns {String}\n     */\n    getBitsPastSubnet() {\n        return this.getBitsBase2(this.subnetMask, constants6.BITS);\n    }\n    /**\n     * Return the reversed ip6.arpa form of the address\n     * @memberof Address6\n     * @param {Object} options\n     * @param {boolean} options.omitSuffix - omit the \"ip6.arpa\" suffix\n     * @instance\n     * @returns {String}\n     */\n    reverseForm(options) {\n        if (!options) {\n            options = {};\n        }\n        const characters = Math.floor(this.subnetMask / 4);\n        const reversed = this.canonicalForm()\n            .replace(/:/g, '')\n            .split('')\n            .slice(0, characters)\n            .reverse()\n            .join('.');\n        if (characters > 0) {\n            if (options.omitSuffix) {\n                return reversed;\n            }\n            return `${reversed}.ip6.arpa.`;\n        }\n        if (options.omitSuffix) {\n            return '';\n        }\n        return 'ip6.arpa.';\n    }\n    /**\n     * Return the correct form of the address\n     * @memberof Address6\n     * @instance\n     * @returns {String}\n     */\n    correctForm() {\n        let i;\n        let groups = [];\n        let zeroCounter = 0;\n        const zeroes = [];\n        for (i = 0; i < this.parsedAddress.length; i++) {\n            const value = parseInt(this.parsedAddress[i], 16);\n            if (value === 0) {\n                zeroCounter++;\n            }\n            if (value !== 0 && zeroCounter > 0) {\n                if (zeroCounter > 1) {\n                    zeroes.push([i - zeroCounter, i - 1]);\n                }\n                zeroCounter = 0;\n            }\n        }\n        // Do we end with a string of zeroes?\n        if (zeroCounter > 1) {\n            zeroes.push([this.parsedAddress.length - zeroCounter, this.parsedAddress.length - 1]);\n        }\n        const zeroLengths = zeroes.map((n) => n[1] - n[0] + 1);\n        if (zeroes.length > 0) {\n            const index = zeroLengths.indexOf(Math.max(...zeroLengths));\n            groups = compact(this.parsedAddress, zeroes[index]);\n        }\n        else {\n            groups = this.parsedAddress;\n        }\n        for (i = 0; i < groups.length; i++) {\n            if (groups[i] !== 'compact') {\n                groups[i] = parseInt(groups[i], 16).toString(16);\n            }\n        }\n        let correct = groups.join(':');\n        correct = correct.replace(/^compact$/, '::');\n        correct = correct.replace(/(^compact)|(compact$)/, ':');\n        correct = correct.replace(/compact/, '');\n        return correct;\n    }\n    /**\n     * Return a zero-padded base-2 string representation of the address\n     * @memberof Address6\n     * @instance\n     * @returns {String}\n     * @example\n     * var address = new Address6('2001:4860:4001:803::1011');\n     * address.binaryZeroPad();\n     * // '0010000000000001010010000110000001000000000000010000100000000011\n     * //  0000000000000000000000000000000000000000000000000001000000010001'\n     */\n    binaryZeroPad() {\n        return this.bigInt().toString(2).padStart(constants6.BITS, '0');\n    }\n    // TODO: Improve the semantics of this helper function\n    parse4in6(address) {\n        const groups = address.split(':');\n        const lastGroup = groups.slice(-1)[0];\n        const address4 = lastGroup.match(constants4.RE_ADDRESS);\n        if (address4) {\n            this.parsedAddress4 = address4[0];\n            this.address4 = new ipv4_1.Address4(this.parsedAddress4);\n            for (let i = 0; i < this.address4.groups; i++) {\n                if (/^0[0-9]+/.test(this.address4.parsedAddress[i])) {\n                    throw new address_error_1.AddressError(\"IPv4 addresses can't have leading zeroes.\", address.replace(constants4.RE_ADDRESS, this.address4.parsedAddress.map(spanLeadingZeroes4).join('.')));\n                }\n            }\n            this.v4 = true;\n            groups[groups.length - 1] = this.address4.toGroup6();\n            address = groups.join(':');\n        }\n        return address;\n    }\n    // TODO: Make private?\n    parse(address) {\n        address = this.parse4in6(address);\n        const badCharacters = address.match(constants6.RE_BAD_CHARACTERS);\n        if (badCharacters) {\n            throw new address_error_1.AddressError(`Bad character${badCharacters.length > 1 ? 's' : ''} detected in address: ${badCharacters.join('')}`, address.replace(constants6.RE_BAD_CHARACTERS, '<span class=\"parse-error\">$1</span>'));\n        }\n        const badAddress = address.match(constants6.RE_BAD_ADDRESS);\n        if (badAddress) {\n            throw new address_error_1.AddressError(`Address failed regex: ${badAddress.join('')}`, address.replace(constants6.RE_BAD_ADDRESS, '<span class=\"parse-error\">$1</span>'));\n        }\n        let groups = [];\n        const halves = address.split('::');\n        if (halves.length === 2) {\n            let first = halves[0].split(':');\n            let last = halves[1].split(':');\n            if (first.length === 1 && first[0] === '') {\n                first = [];\n            }\n            if (last.length === 1 && last[0] === '') {\n                last = [];\n            }\n            const remaining = this.groups - (first.length + last.length);\n            if (!remaining) {\n                throw new address_error_1.AddressError('Error parsing groups');\n            }\n            this.elidedGroups = remaining;\n            this.elisionBegin = first.length;\n            this.elisionEnd = first.length + this.elidedGroups;\n            groups = groups.concat(first);\n            for (let i = 0; i < remaining; i++) {\n                groups.push('0');\n            }\n            groups = groups.concat(last);\n        }\n        else if (halves.length === 1) {\n            groups = address.split(':');\n            this.elidedGroups = 0;\n        }\n        else {\n            throw new address_error_1.AddressError('Too many :: groups found');\n        }\n        groups = groups.map((group) => parseInt(group, 16).toString(16));\n        if (groups.length !== this.groups) {\n            throw new address_error_1.AddressError('Incorrect number of groups found');\n        }\n        return groups;\n    }\n    /**\n     * Return the canonical form of the address\n     * @memberof Address6\n     * @instance\n     * @returns {String}\n     */\n    canonicalForm() {\n        return this.parsedAddress.map(paddedHex).join(':');\n    }\n    /**\n     * Return the decimal form of the address\n     * @memberof Address6\n     * @instance\n     * @returns {String}\n     */\n    decimal() {\n        return this.parsedAddress.map((n) => parseInt(n, 16).toString(10).padStart(5, '0')).join(':');\n    }\n    /**\n     * Return the address as a BigInt\n     * @memberof Address6\n     * @instance\n     * @returns {bigint}\n     */\n    bigInt() {\n        return BigInt(`0x${this.parsedAddress.map(paddedHex).join('')}`);\n    }\n    /**\n     * Return the last two groups of this address as an IPv4 address string\n     * @memberof Address6\n     * @instance\n     * @returns {Address4}\n     * @example\n     * var address = new Address6('2001:4860:4001::1825:bf11');\n     * address.to4().correctForm(); // '24.37.191.17'\n     */\n    to4() {\n        const binary = this.binaryZeroPad().split('');\n        return ipv4_1.Address4.fromHex(BigInt(`0b${binary.slice(96, 128).join('')}`).toString(16));\n    }\n    /**\n     * Return the v4-in-v6 form of the address\n     * @memberof Address6\n     * @instance\n     * @returns {String}\n     */\n    to4in6() {\n        const address4 = this.to4();\n        const address6 = new Address6(this.parsedAddress.slice(0, 6).join(':'), 6);\n        const correct = address6.correctForm();\n        let infix = '';\n        if (!/:$/.test(correct)) {\n            infix = ':';\n        }\n        return correct + infix + address4.address;\n    }\n    /**\n     * Return an object containing the Teredo properties of the address\n     * @memberof Address6\n     * @instance\n     * @returns {Object}\n     */\n    inspectTeredo() {\n        /*\n        - Bits 0 to 31 are set to the Teredo prefix (normally 2001:0000::/32).\n        - Bits 32 to 63 embed the primary IPv4 address of the Teredo server that\n          is used.\n        - Bits 64 to 79 can be used to define some flags. Currently only the\n          higher order bit is used; it is set to 1 if the Teredo client is\n          located behind a cone NAT, 0 otherwise. For Microsoft's Windows Vista\n          and Windows Server 2008 implementations, more bits are used. In those\n          implementations, the format for these 16 bits is \"CRAAAAUG AAAAAAAA\",\n          where \"C\" remains the \"Cone\" flag. The \"R\" bit is reserved for future\n          use. The \"U\" bit is for the Universal/Local flag (set to 0). The \"G\" bit\n          is Individual/Group flag (set to 0). The A bits are set to a 12-bit\n          randomly generated number chosen by the Teredo client to introduce\n          additional protection for the Teredo node against IPv6-based scanning\n          attacks.\n        - Bits 80 to 95 contains the obfuscated UDP port number. This is the\n          port number that is mapped by the NAT to the Teredo client with all\n          bits inverted.\n        - Bits 96 to 127 contains the obfuscated IPv4 address. This is the\n          public IPv4 address of the NAT with all bits inverted.\n        */\n        const prefix = this.getBitsBase16(0, 32);\n        const bitsForUdpPort = this.getBits(80, 96);\n        // eslint-disable-next-line no-bitwise\n        const udpPort = (bitsForUdpPort ^ BigInt('0xffff')).toString();\n        const server4 = ipv4_1.Address4.fromHex(this.getBitsBase16(32, 64));\n        const bitsForClient4 = this.getBits(96, 128);\n        // eslint-disable-next-line no-bitwise\n        const client4 = ipv4_1.Address4.fromHex((bitsForClient4 ^ BigInt('0xffffffff')).toString(16));\n        const flagsBase2 = this.getBitsBase2(64, 80);\n        const coneNat = (0, common_1.testBit)(flagsBase2, 15);\n        const reserved = (0, common_1.testBit)(flagsBase2, 14);\n        const groupIndividual = (0, common_1.testBit)(flagsBase2, 8);\n        const universalLocal = (0, common_1.testBit)(flagsBase2, 9);\n        const nonce = BigInt(`0b${flagsBase2.slice(2, 6) + flagsBase2.slice(8, 16)}`).toString(10);\n        return {\n            prefix: `${prefix.slice(0, 4)}:${prefix.slice(4, 8)}`,\n            server4: server4.address,\n            client4: client4.address,\n            flags: flagsBase2,\n            coneNat,\n            microsoft: {\n                reserved,\n                universalLocal,\n                groupIndividual,\n                nonce,\n            },\n            udpPort,\n        };\n    }\n    /**\n     * Return an object containing the 6to4 properties of the address\n     * @memberof Address6\n     * @instance\n     * @returns {Object}\n     */\n    inspect6to4() {\n        /*\n        - Bits 0 to 15 are set to the 6to4 prefix (2002::/16).\n        - Bits 16 to 48 embed the IPv4 address of the 6to4 gateway that is used.\n        */\n        const prefix = this.getBitsBase16(0, 16);\n        const gateway = ipv4_1.Address4.fromHex(this.getBitsBase16(16, 48));\n        return {\n            prefix: prefix.slice(0, 4),\n            gateway: gateway.address,\n        };\n    }\n    /**\n     * Return a v6 6to4 address from a v6 v4inv6 address\n     * @memberof Address6\n     * @instance\n     * @returns {Address6}\n     */\n    to6to4() {\n        if (!this.is4()) {\n            return null;\n        }\n        const addr6to4 = [\n            '2002',\n            this.getBitsBase16(96, 112),\n            this.getBitsBase16(112, 128),\n            '',\n            '/16',\n        ].join(':');\n        return new Address6(addr6to4);\n    }\n    /**\n     * Return a byte array\n     * @memberof Address6\n     * @instance\n     * @returns {Array}\n     */\n    toByteArray() {\n        const valueWithoutPadding = this.bigInt().toString(16);\n        const leadingPad = '0'.repeat(valueWithoutPadding.length % 2);\n        const value = `${leadingPad}${valueWithoutPadding}`;\n        const bytes = [];\n        for (let i = 0, length = value.length; i < length; i += 2) {\n            bytes.push(parseInt(value.substring(i, i + 2), 16));\n        }\n        return bytes;\n    }\n    /**\n     * Return an unsigned byte array\n     * @memberof Address6\n     * @instance\n     * @returns {Array}\n     */\n    toUnsignedByteArray() {\n        return this.toByteArray().map(unsignByte);\n    }\n    /**\n     * Convert a byte array to an Address6 object\n     * @memberof Address6\n     * @static\n     * @returns {Address6}\n     */\n    static fromByteArray(bytes) {\n        return this.fromUnsignedByteArray(bytes.map(unsignByte));\n    }\n    /**\n     * Convert an unsigned byte array to an Address6 object\n     * @memberof Address6\n     * @static\n     * @returns {Address6}\n     */\n    static fromUnsignedByteArray(bytes) {\n        const BYTE_MAX = BigInt('256');\n        let result = BigInt('0');\n        let multiplier = BigInt('1');\n        for (let i = bytes.length - 1; i >= 0; i--) {\n            result += multiplier * BigInt(bytes[i].toString(10));\n            multiplier *= BYTE_MAX;\n        }\n        return Address6.fromBigInt(result);\n    }\n    /**\n     * Returns true if the address is in the canonical form, false otherwise\n     * @memberof Address6\n     * @instance\n     * @returns {boolean}\n     */\n    isCanonical() {\n        return this.addressMinusSuffix === this.canonicalForm();\n    }\n    /**\n     * Returns true if the address is a link local address, false otherwise\n     * @memberof Address6\n     * @instance\n     * @returns {boolean}\n     */\n    isLinkLocal() {\n        // Zeroes are required, i.e. we can't check isInSubnet with 'fe80::/10'\n        if (this.getBitsBase2(0, 64) ===\n            '1111111010000000000000000000000000000000000000000000000000000000') {\n            return true;\n        }\n        return false;\n    }\n    /**\n     * Returns true if the address is a multicast address, false otherwise\n     * @memberof Address6\n     * @instance\n     * @returns {boolean}\n     */\n    isMulticast() {\n        return this.getType() === 'Multicast';\n    }\n    /**\n     * Returns true if the address is a v4-in-v6 address, false otherwise\n     * @memberof Address6\n     * @instance\n     * @returns {boolean}\n     */\n    is4() {\n        return this.v4;\n    }\n    /**\n     * Returns true if the address is a Teredo address, false otherwise\n     * @memberof Address6\n     * @instance\n     * @returns {boolean}\n     */\n    isTeredo() {\n        return this.isInSubnet(new Address6('2001::/32'));\n    }\n    /**\n     * Returns true if the address is a 6to4 address, false otherwise\n     * @memberof Address6\n     * @instance\n     * @returns {boolean}\n     */\n    is6to4() {\n        return this.isInSubnet(new Address6('2002::/16'));\n    }\n    /**\n     * Returns true if the address is a loopback address, false otherwise\n     * @memberof Address6\n     * @instance\n     * @returns {boolean}\n     */\n    isLoopback() {\n        return this.getType() === 'Loopback';\n    }\n    // #endregion\n    // #region HTML\n    /**\n     * @returns {String} the address in link form with a default port of 80\n     */\n    href(optionalPort) {\n        if (optionalPort === undefined) {\n            optionalPort = '';\n        }\n        else {\n            optionalPort = `:${optionalPort}`;\n        }\n        return `http://[${this.correctForm()}]${optionalPort}/`;\n    }\n    /**\n     * @returns {String} a link suitable for conveying the address via a URL hash\n     */\n    link(options) {\n        if (!options) {\n            options = {};\n        }\n        if (options.className === undefined) {\n            options.className = '';\n        }\n        if (options.prefix === undefined) {\n            options.prefix = '/#address=';\n        }\n        if (options.v4 === undefined) {\n            options.v4 = false;\n        }\n        let formFunction = this.correctForm;\n        if (options.v4) {\n            formFunction = this.to4in6;\n        }\n        const form = formFunction.call(this);\n        if (options.className) {\n            return `<a href=\"${options.prefix}${form}\" class=\"${options.className}\">${form}</a>`;\n        }\n        return `<a href=\"${options.prefix}${form}\">${form}</a>`;\n    }\n    /**\n     * Groups an address\n     * @returns {String}\n     */\n    group() {\n        if (this.elidedGroups === 0) {\n            // The simple case\n            return helpers.simpleGroup(this.address).join(':');\n        }\n        assert(typeof this.elidedGroups === 'number');\n        assert(typeof this.elisionBegin === 'number');\n        // The elided case\n        const output = [];\n        const [left, right] = this.address.split('::');\n        if (left.length) {\n            output.push(...helpers.simpleGroup(left));\n        }\n        else {\n            output.push('');\n        }\n        const classes = ['hover-group'];\n        for (let i = this.elisionBegin; i < this.elisionBegin + this.elidedGroups; i++) {\n            classes.push(`group-${i}`);\n        }\n        output.push(`<span class=\"${classes.join(' ')}\"></span>`);\n        if (right.length) {\n            output.push(...helpers.simpleGroup(right, this.elisionEnd));\n        }\n        else {\n            output.push('');\n        }\n        if (this.is4()) {\n            assert(this.address4 instanceof ipv4_1.Address4);\n            output.pop();\n            output.push(this.address4.groupForV6());\n        }\n        return output.join(':');\n    }\n    // #endregion\n    // #region Regular expressions\n    /**\n     * Generate a regular expression string that can be used to find or validate\n     * all variations of this address\n     * @memberof Address6\n     * @instance\n     * @param {boolean} substringSearch\n     * @returns {string}\n     */\n    regularExpressionString(substringSearch = false) {\n        let output = [];\n        // TODO: revisit why this is necessary\n        const address6 = new Address6(this.correctForm());\n        if (address6.elidedGroups === 0) {\n            // The simple case\n            output.push((0, regular_expressions_1.simpleRegularExpression)(address6.parsedAddress));\n        }\n        else if (address6.elidedGroups === constants6.GROUPS) {\n            // A completely elided address\n            output.push((0, regular_expressions_1.possibleElisions)(constants6.GROUPS));\n        }\n        else {\n            // A partially elided address\n            const halves = address6.address.split('::');\n            if (halves[0].length) {\n                output.push((0, regular_expressions_1.simpleRegularExpression)(halves[0].split(':')));\n            }\n            assert(typeof address6.elidedGroups === 'number');\n            output.push((0, regular_expressions_1.possibleElisions)(address6.elidedGroups, halves[0].length !== 0, halves[1].length !== 0));\n            if (halves[1].length) {\n                output.push((0, regular_expressions_1.simpleRegularExpression)(halves[1].split(':')));\n            }\n            output = [output.join(':')];\n        }\n        if (!substringSearch) {\n            output = [\n                '(?=^|',\n                regular_expressions_1.ADDRESS_BOUNDARY,\n                '|[^\\\\w\\\\:])(',\n                ...output,\n                ')(?=[^\\\\w\\\\:]|',\n                regular_expressions_1.ADDRESS_BOUNDARY,\n                '|$)',\n            ];\n        }\n        return output.join('');\n    }\n    /**\n     * Generate a regular expression that can be used to find or validate all\n     * variations of this address.\n     * @memberof Address6\n     * @instance\n     * @param {boolean} substringSearch\n     * @returns {RegExp}\n     */\n    regularExpression(substringSearch = false) {\n        return new RegExp(this.regularExpressionString(substringSearch), 'i');\n    }\n}\nexports.Address6 = Address6;\n//# sourceMappingURL=ipv6.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaXAtYWRkcmVzcy9kaXN0L2lwdjYuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG9DQUFvQztBQUNuRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSwwQ0FBMEMsNEJBQTRCO0FBQ3RFLENBQUM7QUFDRDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxnQkFBZ0I7QUFDaEIsNEJBQTRCLG1CQUFPLENBQUMsZ0VBQVU7QUFDOUMsZ0NBQWdDLG1CQUFPLENBQUMsNEVBQWdCO0FBQ3hELGdDQUFnQyxtQkFBTyxDQUFDLDRFQUFnQjtBQUN4RCw2QkFBNkIsbUJBQU8sQ0FBQyx3RUFBYztBQUNuRCxlQUFlLG1CQUFPLENBQUMsNERBQVE7QUFDL0IsOEJBQThCLG1CQUFPLENBQUMsZ0dBQTBCO0FBQ2hFLHdCQUF3QixtQkFBTyxDQUFDLDhFQUFpQjtBQUNqRCxpQkFBaUIsbUJBQU8sQ0FBQyxnRUFBVTtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsRUFBRTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsR0FBRztBQUMxQix1QkFBdUIsR0FBRztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isb0JBQW9CO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbWVyY2hhbnRhaS1hZG1pbi8uL25vZGVfbW9kdWxlcy9pcC1hZGRyZXNzL2Rpc3QvaXB2Ni5qcz9iN2M5Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLyogZXNsaW50LWRpc2FibGUgcHJlZmVyLWRlc3RydWN0dXJpbmcgKi9cbi8qIGVzbGludC1kaXNhYmxlIG5vLXBhcmFtLXJlYXNzaWduICovXG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IobSwgayk7XG4gICAgaWYgKCFkZXNjIHx8IChcImdldFwiIGluIGRlc2MgPyAhbS5fX2VzTW9kdWxlIDogZGVzYy53cml0YWJsZSB8fCBkZXNjLmNvbmZpZ3VyYWJsZSkpIHtcbiAgICAgIGRlc2MgPSB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH07XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgZGVzYyk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fc2V0TW9kdWxlRGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19zZXRNb2R1bGVEZWZhdWx0KSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCB2KSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIFwiZGVmYXVsdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2IH0pO1xufSkgOiBmdW5jdGlvbihvLCB2KSB7XG4gICAgb1tcImRlZmF1bHRcIl0gPSB2O1xufSk7XG52YXIgX19pbXBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydFN0YXIpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoayAhPT0gXCJkZWZhdWx0XCIgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIF9fY3JlYXRlQmluZGluZyhyZXN1bHQsIG1vZCwgayk7XG4gICAgX19zZXRNb2R1bGVEZWZhdWx0KHJlc3VsdCwgbW9kKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQWRkcmVzczYgPSB2b2lkIDA7XG5jb25zdCBjb21tb24gPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcIi4vY29tbW9uXCIpKTtcbmNvbnN0IGNvbnN0YW50czQgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcIi4vdjQvY29uc3RhbnRzXCIpKTtcbmNvbnN0IGNvbnN0YW50czYgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcIi4vdjYvY29uc3RhbnRzXCIpKTtcbmNvbnN0IGhlbHBlcnMgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcIi4vdjYvaGVscGVyc1wiKSk7XG5jb25zdCBpcHY0XzEgPSByZXF1aXJlKFwiLi9pcHY0XCIpO1xuY29uc3QgcmVndWxhcl9leHByZXNzaW9uc18xID0gcmVxdWlyZShcIi4vdjYvcmVndWxhci1leHByZXNzaW9uc1wiKTtcbmNvbnN0IGFkZHJlc3NfZXJyb3JfMSA9IHJlcXVpcmUoXCIuL2FkZHJlc3MtZXJyb3JcIik7XG5jb25zdCBjb21tb25fMSA9IHJlcXVpcmUoXCIuL2NvbW1vblwiKTtcbmZ1bmN0aW9uIGFzc2VydChjb25kaXRpb24pIHtcbiAgICBpZiAoIWNvbmRpdGlvbikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Fzc2VydGlvbiBmYWlsZWQuJyk7XG4gICAgfVxufVxuZnVuY3Rpb24gYWRkQ29tbWFzKG51bWJlcikge1xuICAgIGNvbnN0IHIgPSAvKFxcZCspKFxcZHszfSkvO1xuICAgIHdoaWxlIChyLnRlc3QobnVtYmVyKSkge1xuICAgICAgICBudW1iZXIgPSBudW1iZXIucmVwbGFjZShyLCAnJDEsJDInKTtcbiAgICB9XG4gICAgcmV0dXJuIG51bWJlcjtcbn1cbmZ1bmN0aW9uIHNwYW5MZWFkaW5nWmVyb2VzNChuKSB7XG4gICAgbiA9IG4ucmVwbGFjZSgvXigwezEsfSkoWzEtOV0rKSQvLCAnPHNwYW4gY2xhc3M9XCJwYXJzZS1lcnJvclwiPiQxPC9zcGFuPiQyJyk7XG4gICAgbiA9IG4ucmVwbGFjZSgvXigwezEsfSkoMCkkLywgJzxzcGFuIGNsYXNzPVwicGFyc2UtZXJyb3JcIj4kMTwvc3Bhbj4kMicpO1xuICAgIHJldHVybiBuO1xufVxuLypcbiAqIEEgaGVscGVyIGZ1bmN0aW9uIHRvIGNvbXBhY3QgYW4gYXJyYXlcbiAqL1xuZnVuY3Rpb24gY29tcGFjdChhZGRyZXNzLCBzbGljZSkge1xuICAgIGNvbnN0IHMxID0gW107XG4gICAgY29uc3QgczIgPSBbXTtcbiAgICBsZXQgaTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgYWRkcmVzcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoaSA8IHNsaWNlWzBdKSB7XG4gICAgICAgICAgICBzMS5wdXNoKGFkZHJlc3NbaV0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGkgPiBzbGljZVsxXSkge1xuICAgICAgICAgICAgczIucHVzaChhZGRyZXNzW2ldKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gczEuY29uY2F0KFsnY29tcGFjdCddKS5jb25jYXQoczIpO1xufVxuZnVuY3Rpb24gcGFkZGVkSGV4KG9jdGV0KSB7XG4gICAgcmV0dXJuIHBhcnNlSW50KG9jdGV0LCAxNikudG9TdHJpbmcoMTYpLnBhZFN0YXJ0KDQsICcwJyk7XG59XG5mdW5jdGlvbiB1bnNpZ25CeXRlKGIpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tYml0d2lzZVxuICAgIHJldHVybiBiICYgMHhmZjtcbn1cbi8qKlxuICogUmVwcmVzZW50cyBhbiBJUHY2IGFkZHJlc3NcbiAqIEBjbGFzcyBBZGRyZXNzNlxuICogQHBhcmFtIHtzdHJpbmd9IGFkZHJlc3MgLSBBbiBJUHY2IGFkZHJlc3Mgc3RyaW5nXG4gKiBAcGFyYW0ge251bWJlcn0gW2dyb3Vwcz04XSAtIEhvdyBtYW55IG9jdGV0cyB0byBwYXJzZVxuICogQGV4YW1wbGVcbiAqIHZhciBhZGRyZXNzID0gbmV3IEFkZHJlc3M2KCcyMDAxOjovMzInKTtcbiAqL1xuY2xhc3MgQWRkcmVzczYge1xuICAgIGNvbnN0cnVjdG9yKGFkZHJlc3MsIG9wdGlvbmFsR3JvdXBzKSB7XG4gICAgICAgIHRoaXMuYWRkcmVzc01pbnVzU3VmZml4ID0gJyc7XG4gICAgICAgIHRoaXMucGFyc2VkU3VibmV0ID0gJyc7XG4gICAgICAgIHRoaXMuc3VibmV0ID0gJy8xMjgnO1xuICAgICAgICB0aGlzLnN1Ym5ldE1hc2sgPSAxMjg7XG4gICAgICAgIHRoaXMudjQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy56b25lID0gJyc7XG4gICAgICAgIC8vICNyZWdpb24gQXR0cmlidXRlc1xuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiBhZGRyZXNzIGlzIGluIHRoZSBzdWJuZXQgb2YgdGhlIGN1cnJlbnQgYWRkcmVzc1xuICAgICAgICAgKiBAbWVtYmVyb2YgQWRkcmVzczZcbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5pc0luU3VibmV0ID0gY29tbW9uLmlzSW5TdWJuZXQ7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIGFkZHJlc3MgaXMgY29ycmVjdCwgZmFsc2Ugb3RoZXJ3aXNlXG4gICAgICAgICAqIEBtZW1iZXJvZiBBZGRyZXNzNlxuICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmlzQ29ycmVjdCA9IGNvbW1vbi5pc0NvcnJlY3QoY29uc3RhbnRzNi5CSVRTKTtcbiAgICAgICAgaWYgKG9wdGlvbmFsR3JvdXBzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuZ3JvdXBzID0gY29uc3RhbnRzNi5HUk9VUFM7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmdyb3VwcyA9IG9wdGlvbmFsR3JvdXBzO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYWRkcmVzcyA9IGFkZHJlc3M7XG4gICAgICAgIGNvbnN0IHN1Ym5ldCA9IGNvbnN0YW50czYuUkVfU1VCTkVUX1NUUklORy5leGVjKGFkZHJlc3MpO1xuICAgICAgICBpZiAoc3VibmV0KSB7XG4gICAgICAgICAgICB0aGlzLnBhcnNlZFN1Ym5ldCA9IHN1Ym5ldFswXS5yZXBsYWNlKCcvJywgJycpO1xuICAgICAgICAgICAgdGhpcy5zdWJuZXRNYXNrID0gcGFyc2VJbnQodGhpcy5wYXJzZWRTdWJuZXQsIDEwKTtcbiAgICAgICAgICAgIHRoaXMuc3VibmV0ID0gYC8ke3RoaXMuc3VibmV0TWFza31gO1xuICAgICAgICAgICAgaWYgKE51bWJlci5pc05hTih0aGlzLnN1Ym5ldE1hc2spIHx8XG4gICAgICAgICAgICAgICAgdGhpcy5zdWJuZXRNYXNrIDwgMCB8fFxuICAgICAgICAgICAgICAgIHRoaXMuc3VibmV0TWFzayA+IGNvbnN0YW50czYuQklUUykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBhZGRyZXNzX2Vycm9yXzEuQWRkcmVzc0Vycm9yKCdJbnZhbGlkIHN1Ym5ldCBtYXNrLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYWRkcmVzcyA9IGFkZHJlc3MucmVwbGFjZShjb25zdGFudHM2LlJFX1NVQk5FVF9TVFJJTkcsICcnKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICgvXFwvLy50ZXN0KGFkZHJlc3MpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgYWRkcmVzc19lcnJvcl8xLkFkZHJlc3NFcnJvcignSW52YWxpZCBzdWJuZXQgbWFzay4nKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB6b25lID0gY29uc3RhbnRzNi5SRV9aT05FX1NUUklORy5leGVjKGFkZHJlc3MpO1xuICAgICAgICBpZiAoem9uZSkge1xuICAgICAgICAgICAgdGhpcy56b25lID0gem9uZVswXTtcbiAgICAgICAgICAgIGFkZHJlc3MgPSBhZGRyZXNzLnJlcGxhY2UoY29uc3RhbnRzNi5SRV9aT05FX1NUUklORywgJycpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYWRkcmVzc01pbnVzU3VmZml4ID0gYWRkcmVzcztcbiAgICAgICAgdGhpcy5wYXJzZWRBZGRyZXNzID0gdGhpcy5wYXJzZSh0aGlzLmFkZHJlc3NNaW51c1N1ZmZpeCk7XG4gICAgfVxuICAgIHN0YXRpYyBpc1ZhbGlkKGFkZHJlc3MpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1uZXdcbiAgICAgICAgICAgIG5ldyBBZGRyZXNzNihhZGRyZXNzKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29udmVydCBhIEJpZ0ludCB0byBhIHY2IGFkZHJlc3Mgb2JqZWN0XG4gICAgICogQG1lbWJlcm9mIEFkZHJlc3M2XG4gICAgICogQHN0YXRpY1xuICAgICAqIEBwYXJhbSB7YmlnaW50fSBiaWdJbnQgLSBhIEJpZ0ludCB0byBjb252ZXJ0XG4gICAgICogQHJldHVybnMge0FkZHJlc3M2fVxuICAgICAqIEBleGFtcGxlXG4gICAgICogdmFyIGJpZ0ludCA9IEJpZ0ludCgnMTAwMDAwMDAwMDAwMCcpO1xuICAgICAqIHZhciBhZGRyZXNzID0gQWRkcmVzczYuZnJvbUJpZ0ludChiaWdJbnQpO1xuICAgICAqIGFkZHJlc3MuY29ycmVjdEZvcm0oKTsgLy8gJzo6ZTg6ZDRhNToxMDAwJ1xuICAgICAqL1xuICAgIHN0YXRpYyBmcm9tQmlnSW50KGJpZ0ludCkge1xuICAgICAgICBjb25zdCBoZXggPSBiaWdJbnQudG9TdHJpbmcoMTYpLnBhZFN0YXJ0KDMyLCAnMCcpO1xuICAgICAgICBjb25zdCBncm91cHMgPSBbXTtcbiAgICAgICAgbGV0IGk7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBjb25zdGFudHM2LkdST1VQUzsgaSsrKSB7XG4gICAgICAgICAgICBncm91cHMucHVzaChoZXguc2xpY2UoaSAqIDQsIChpICsgMSkgKiA0KSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBBZGRyZXNzNihncm91cHMuam9pbignOicpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29udmVydCBhIFVSTCAod2l0aCBvcHRpb25hbCBwb3J0IG51bWJlcikgdG8gYW4gYWRkcmVzcyBvYmplY3RcbiAgICAgKiBAbWVtYmVyb2YgQWRkcmVzczZcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHVybCAtIGEgVVJMIHdpdGggb3B0aW9uYWwgcG9ydCBudW1iZXJcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIHZhciBhZGRyZXNzQW5kUG9ydCA9IEFkZHJlc3M2LmZyb21VUkwoJ2h0dHA6Ly9bZmZmZjo6XTo4MDgwL2Zvby8nKTtcbiAgICAgKiBhZGRyZXNzQW5kUG9ydC5hZGRyZXNzLmNvcnJlY3RGb3JtKCk7IC8vICdmZmZmOjonXG4gICAgICogYWRkcmVzc0FuZFBvcnQucG9ydDsgLy8gODA4MFxuICAgICAqL1xuICAgIHN0YXRpYyBmcm9tVVJMKHVybCkge1xuICAgICAgICBsZXQgaG9zdDtcbiAgICAgICAgbGV0IHBvcnQgPSBudWxsO1xuICAgICAgICBsZXQgcmVzdWx0O1xuICAgICAgICAvLyBJZiB3ZSBoYXZlIGJyYWNrZXRzIHBhcnNlIHRoZW0gYW5kIGZpbmQgYSBwb3J0XG4gICAgICAgIGlmICh1cmwuaW5kZXhPZignWycpICE9PSAtMSAmJiB1cmwuaW5kZXhPZignXTonKSAhPT0gLTEpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IGNvbnN0YW50czYuUkVfVVJMX1dJVEhfUE9SVC5leGVjKHVybCk7XG4gICAgICAgICAgICBpZiAocmVzdWx0ID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgZXJyb3I6ICdmYWlsZWQgdG8gcGFyc2UgYWRkcmVzcyB3aXRoIHBvcnQnLFxuICAgICAgICAgICAgICAgICAgICBhZGRyZXNzOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICBwb3J0OiBudWxsLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBob3N0ID0gcmVzdWx0WzFdO1xuICAgICAgICAgICAgcG9ydCA9IHJlc3VsdFsyXTtcbiAgICAgICAgICAgIC8vIElmIHRoZXJlJ3MgYSBVUkwgZXh0cmFjdCB0aGUgYWRkcmVzc1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHVybC5pbmRleE9mKCcvJykgIT09IC0xKSB7XG4gICAgICAgICAgICAvLyBSZW1vdmUgdGhlIHByb3RvY29sIHByZWZpeFxuICAgICAgICAgICAgdXJsID0gdXJsLnJlcGxhY2UoL15bYS16MC05XSs6XFwvXFwvLywgJycpO1xuICAgICAgICAgICAgLy8gUGFyc2UgdGhlIGFkZHJlc3NcbiAgICAgICAgICAgIHJlc3VsdCA9IGNvbnN0YW50czYuUkVfVVJMLmV4ZWModXJsKTtcbiAgICAgICAgICAgIGlmIChyZXN1bHQgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBlcnJvcjogJ2ZhaWxlZCB0byBwYXJzZSBhZGRyZXNzIGZyb20gVVJMJyxcbiAgICAgICAgICAgICAgICAgICAgYWRkcmVzczogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgcG9ydDogbnVsbCxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaG9zdCA9IHJlc3VsdFsxXTtcbiAgICAgICAgICAgIC8vIE90aGVyd2lzZSBqdXN0IGFzc2lnbiB0aGUgVVJMIHRvIHRoZSBob3N0IGFuZCBsZXQgdGhlIGxpYnJhcnkgcGFyc2UgaXRcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGhvc3QgPSB1cmw7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgdGhlcmUncyBhIHBvcnQgY29udmVydCBpdCB0byBhbiBpbnRlZ2VyXG4gICAgICAgIGlmIChwb3J0KSB7XG4gICAgICAgICAgICBwb3J0ID0gcGFyc2VJbnQocG9ydCwgMTApO1xuICAgICAgICAgICAgLy8gc3F1ZWxjaCBvdXQgb2YgcmFuZ2UgcG9ydHNcbiAgICAgICAgICAgIGlmIChwb3J0IDwgMCB8fCBwb3J0ID4gNjU1MzYpIHtcbiAgICAgICAgICAgICAgICBwb3J0ID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIFN0YW5kYXJkaXplIGB1bmRlZmluZWRgIHRvIGBudWxsYFxuICAgICAgICAgICAgcG9ydCA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGFkZHJlc3M6IG5ldyBBZGRyZXNzNihob3N0KSxcbiAgICAgICAgICAgIHBvcnQsXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhbiBJUHY2LW1hcHBlZCBhZGRyZXNzIGdpdmVuIGFuIElQdjQgYWRkcmVzc1xuICAgICAqIEBtZW1iZXJvZiBBZGRyZXNzNlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gYWRkcmVzcyAtIEFuIElQdjQgYWRkcmVzcyBzdHJpbmdcbiAgICAgKiBAcmV0dXJucyB7QWRkcmVzczZ9XG4gICAgICogQGV4YW1wbGVcbiAgICAgKiB2YXIgYWRkcmVzcyA9IEFkZHJlc3M2LmZyb21BZGRyZXNzNCgnMTkyLjE2OC4wLjEnKTtcbiAgICAgKiBhZGRyZXNzLmNvcnJlY3RGb3JtKCk7IC8vICc6OmZmZmY6YzBhODoxJ1xuICAgICAqIGFkZHJlc3MudG80aW42KCk7IC8vICc6OmZmZmY6MTkyLjE2OC4wLjEnXG4gICAgICovXG4gICAgc3RhdGljIGZyb21BZGRyZXNzNChhZGRyZXNzKSB7XG4gICAgICAgIGNvbnN0IGFkZHJlc3M0ID0gbmV3IGlwdjRfMS5BZGRyZXNzNChhZGRyZXNzKTtcbiAgICAgICAgY29uc3QgbWFzazYgPSBjb25zdGFudHM2LkJJVFMgLSAoY29uc3RhbnRzNC5CSVRTIC0gYWRkcmVzczQuc3VibmV0TWFzayk7XG4gICAgICAgIHJldHVybiBuZXcgQWRkcmVzczYoYDo6ZmZmZjoke2FkZHJlc3M0LmNvcnJlY3RGb3JtKCl9LyR7bWFzazZ9YCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybiBhbiBhZGRyZXNzIGZyb20gaXA2LmFycGEgZm9ybVxuICAgICAqIEBtZW1iZXJvZiBBZGRyZXNzNlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gYXJwYUZvcm1BZGRyZXNzIC0gYW4gJ2lwNi5hcnBhJyBmb3JtIGFkZHJlc3NcbiAgICAgKiBAcmV0dXJucyB7QWRyZXNzNn1cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIHZhciBhZGRyZXNzID0gQWRkcmVzczYuZnJvbUFycGEoZS5mLmYuZi4zLmMuMi42LmYuZi5mLmUuNi42LjguZS4xLjAuNi43LjkuNC5lLmMuMC4wLjAuMC4xLjAuMC4yLmlwNi5hcnBhLilcbiAgICAgKiBhZGRyZXNzLmNvcnJlY3RGb3JtKCk7IC8vICcyMDAxOjA6Y2U0OTo3NjAxOmU4NjY6ZWZmZjo2MmMzOmZmZmUnXG4gICAgICovXG4gICAgc3RhdGljIGZyb21BcnBhKGFycGFGb3JtQWRkcmVzcykge1xuICAgICAgICAvLyByZW1vdmUgZW5kaW5nIFwiLmlwNi5hcnBhLlwiIG9yIGp1c3QgXCIuXCJcbiAgICAgICAgbGV0IGFkZHJlc3MgPSBhcnBhRm9ybUFkZHJlc3MucmVwbGFjZSgvKFxcLmlwNlxcLmFycGEpP1xcLiQvLCAnJyk7XG4gICAgICAgIGNvbnN0IHNlbWljb2xvbkFtb3VudCA9IDc7XG4gICAgICAgIC8vIGNvcnJlY3QgaXA2LmFycGEgZm9ybSB3aXRoIGVuZGluZyByZW1vdmVkIHdpbGwgYmUgNjMgY2hhcmFjdGVyc1xuICAgICAgICBpZiAoYWRkcmVzcy5sZW5ndGggIT09IDYzKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgYWRkcmVzc19lcnJvcl8xLkFkZHJlc3NFcnJvcihcIkludmFsaWQgJ2lwNi5hcnBhJyBmb3JtLlwiKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwYXJ0cyA9IGFkZHJlc3Muc3BsaXQoJy4nKS5yZXZlcnNlKCk7XG4gICAgICAgIGZvciAobGV0IGkgPSBzZW1pY29sb25BbW91bnQ7IGkgPiAwOyBpLS0pIHtcbiAgICAgICAgICAgIGNvbnN0IGluc2VydEluZGV4ID0gaSAqIDQ7XG4gICAgICAgICAgICBwYXJ0cy5zcGxpY2UoaW5zZXJ0SW5kZXgsIDAsICc6Jyk7XG4gICAgICAgIH1cbiAgICAgICAgYWRkcmVzcyA9IHBhcnRzLmpvaW4oJycpO1xuICAgICAgICByZXR1cm4gbmV3IEFkZHJlc3M2KGFkZHJlc3MpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gdGhlIE1pY3Jvc29mdCBVTkMgdHJhbnNjcmlwdGlvbiBvZiB0aGUgYWRkcmVzc1xuICAgICAqIEBtZW1iZXJvZiBBZGRyZXNzNlxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEByZXR1cm5zIHtTdHJpbmd9IHRoZSBNaWNyb3NvZnQgVU5DIHRyYW5zY3JpcHRpb24gb2YgdGhlIGFkZHJlc3NcbiAgICAgKi9cbiAgICBtaWNyb3NvZnRUcmFuc2NyaXB0aW9uKCkge1xuICAgICAgICByZXR1cm4gYCR7dGhpcy5jb3JyZWN0Rm9ybSgpLnJlcGxhY2UoLzovZywgJy0nKX0uaXB2Ni1saXRlcmFsLm5ldGA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybiB0aGUgZmlyc3QgbiBiaXRzIG9mIHRoZSBhZGRyZXNzLCBkZWZhdWx0aW5nIHRvIHRoZSBzdWJuZXQgbWFza1xuICAgICAqIEBtZW1iZXJvZiBBZGRyZXNzNlxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbWFzaz1zdWJuZXRdIC0gdGhlIG51bWJlciBvZiBiaXRzIHRvIG1hc2tcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfSB0aGUgZmlyc3QgbiBiaXRzIG9mIHRoZSBhZGRyZXNzIGFzIGEgc3RyaW5nXG4gICAgICovXG4gICAgbWFzayhtYXNrID0gdGhpcy5zdWJuZXRNYXNrKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldEJpdHNCYXNlMigwLCBtYXNrKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJuIHRoZSBudW1iZXIgb2YgcG9zc2libGUgc3VibmV0cyBvZiBhIGdpdmVuIHNpemUgaW4gdGhlIGFkZHJlc3NcbiAgICAgKiBAbWVtYmVyb2YgQWRkcmVzczZcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3N1Ym5ldFNpemU9MTI4XSAtIHRoZSBzdWJuZXQgc2l6ZVxuICAgICAqIEByZXR1cm5zIHtTdHJpbmd9XG4gICAgICovXG4gICAgLy8gVE9ETzogcHJvYmFibHkgdXNlZnVsIHRvIGhhdmUgYSBudW1lcmljIHZlcnNpb24gb2YgdGhpcyB0b29cbiAgICBwb3NzaWJsZVN1Ym5ldHMoc3VibmV0U2l6ZSA9IDEyOCkge1xuICAgICAgICBjb25zdCBhdmFpbGFibGVCaXRzID0gY29uc3RhbnRzNi5CSVRTIC0gdGhpcy5zdWJuZXRNYXNrO1xuICAgICAgICBjb25zdCBzdWJuZXRCaXRzID0gTWF0aC5hYnMoc3VibmV0U2l6ZSAtIGNvbnN0YW50czYuQklUUyk7XG4gICAgICAgIGNvbnN0IHN1Ym5ldFBvd2VycyA9IGF2YWlsYWJsZUJpdHMgLSBzdWJuZXRCaXRzO1xuICAgICAgICBpZiAoc3VibmV0UG93ZXJzIDwgMCkge1xuICAgICAgICAgICAgcmV0dXJuICcwJztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYWRkQ29tbWFzKChCaWdJbnQoJzInKSAqKiBCaWdJbnQoc3VibmV0UG93ZXJzKSkudG9TdHJpbmcoMTApKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSGVscGVyIGZ1bmN0aW9uIGdldHRpbmcgc3RhcnQgYWRkcmVzcy5cbiAgICAgKiBAbWVtYmVyb2YgQWRkcmVzczZcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAcmV0dXJucyB7YmlnaW50fVxuICAgICAqL1xuICAgIF9zdGFydEFkZHJlc3MoKSB7XG4gICAgICAgIHJldHVybiBCaWdJbnQoYDBiJHt0aGlzLm1hc2soKSArICcwJy5yZXBlYXQoY29uc3RhbnRzNi5CSVRTIC0gdGhpcy5zdWJuZXRNYXNrKX1gKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIGZpcnN0IGFkZHJlc3MgaW4gdGhlIHJhbmdlIGdpdmVuIGJ5IHRoaXMgYWRkcmVzcycgc3VibmV0XG4gICAgICogT2Z0ZW4gcmVmZXJyZWQgdG8gYXMgdGhlIE5ldHdvcmsgQWRkcmVzcy5cbiAgICAgKiBAbWVtYmVyb2YgQWRkcmVzczZcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAcmV0dXJucyB7QWRkcmVzczZ9XG4gICAgICovXG4gICAgc3RhcnRBZGRyZXNzKCkge1xuICAgICAgICByZXR1cm4gQWRkcmVzczYuZnJvbUJpZ0ludCh0aGlzLl9zdGFydEFkZHJlc3MoKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSBmaXJzdCBob3N0IGFkZHJlc3MgaW4gdGhlIHJhbmdlIGdpdmVuIGJ5IHRoaXMgYWRkcmVzcydzIHN1Ym5ldCBpZVxuICAgICAqIHRoZSBmaXJzdCBhZGRyZXNzIGFmdGVyIHRoZSBOZXR3b3JrIEFkZHJlc3NcbiAgICAgKiBAbWVtYmVyb2YgQWRkcmVzczZcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAcmV0dXJucyB7QWRkcmVzczZ9XG4gICAgICovXG4gICAgc3RhcnRBZGRyZXNzRXhjbHVzaXZlKCkge1xuICAgICAgICBjb25zdCBhZGp1c3QgPSBCaWdJbnQoJzEnKTtcbiAgICAgICAgcmV0dXJuIEFkZHJlc3M2LmZyb21CaWdJbnQodGhpcy5fc3RhcnRBZGRyZXNzKCkgKyBhZGp1c3QpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBIZWxwZXIgZnVuY3Rpb24gZ2V0dGluZyBlbmQgYWRkcmVzcy5cbiAgICAgKiBAbWVtYmVyb2YgQWRkcmVzczZcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAcmV0dXJucyB7YmlnaW50fVxuICAgICAqL1xuICAgIF9lbmRBZGRyZXNzKCkge1xuICAgICAgICByZXR1cm4gQmlnSW50KGAwYiR7dGhpcy5tYXNrKCkgKyAnMScucmVwZWF0KGNvbnN0YW50czYuQklUUyAtIHRoaXMuc3VibmV0TWFzayl9YCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSBsYXN0IGFkZHJlc3MgaW4gdGhlIHJhbmdlIGdpdmVuIGJ5IHRoaXMgYWRkcmVzcycgc3VibmV0XG4gICAgICogT2Z0ZW4gcmVmZXJyZWQgdG8gYXMgdGhlIEJyb2FkY2FzdFxuICAgICAqIEBtZW1iZXJvZiBBZGRyZXNzNlxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEByZXR1cm5zIHtBZGRyZXNzNn1cbiAgICAgKi9cbiAgICBlbmRBZGRyZXNzKCkge1xuICAgICAgICByZXR1cm4gQWRkcmVzczYuZnJvbUJpZ0ludCh0aGlzLl9lbmRBZGRyZXNzKCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgbGFzdCBob3N0IGFkZHJlc3MgaW4gdGhlIHJhbmdlIGdpdmVuIGJ5IHRoaXMgYWRkcmVzcydzIHN1Ym5ldCBpZVxuICAgICAqIHRoZSBsYXN0IGFkZHJlc3MgcHJpb3IgdG8gdGhlIEJyb2FkY2FzdCBBZGRyZXNzXG4gICAgICogQG1lbWJlcm9mIEFkZHJlc3M2XG4gICAgICogQGluc3RhbmNlXG4gICAgICogQHJldHVybnMge0FkZHJlc3M2fVxuICAgICAqL1xuICAgIGVuZEFkZHJlc3NFeGNsdXNpdmUoKSB7XG4gICAgICAgIGNvbnN0IGFkanVzdCA9IEJpZ0ludCgnMScpO1xuICAgICAgICByZXR1cm4gQWRkcmVzczYuZnJvbUJpZ0ludCh0aGlzLl9lbmRBZGRyZXNzKCkgLSBhZGp1c3QpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gdGhlIHNjb3BlIG9mIHRoZSBhZGRyZXNzXG4gICAgICogQG1lbWJlcm9mIEFkZHJlc3M2XG4gICAgICogQGluc3RhbmNlXG4gICAgICogQHJldHVybnMge1N0cmluZ31cbiAgICAgKi9cbiAgICBnZXRTY29wZSgpIHtcbiAgICAgICAgbGV0IHNjb3BlID0gY29uc3RhbnRzNi5TQ09QRVNbcGFyc2VJbnQodGhpcy5nZXRCaXRzKDEyLCAxNikudG9TdHJpbmcoMTApLCAxMCldO1xuICAgICAgICBpZiAodGhpcy5nZXRUeXBlKCkgPT09ICdHbG9iYWwgdW5pY2FzdCcgJiYgc2NvcGUgIT09ICdMaW5rIGxvY2FsJykge1xuICAgICAgICAgICAgc2NvcGUgPSAnR2xvYmFsJztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2NvcGUgfHwgJ1Vua25vd24nO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gdGhlIHR5cGUgb2YgdGhlIGFkZHJlc3NcbiAgICAgKiBAbWVtYmVyb2YgQWRkcmVzczZcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfVxuICAgICAqL1xuICAgIGdldFR5cGUoKSB7XG4gICAgICAgIGZvciAoY29uc3Qgc3VibmV0IG9mIE9iamVjdC5rZXlzKGNvbnN0YW50czYuVFlQRVMpKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5pc0luU3VibmV0KG5ldyBBZGRyZXNzNihzdWJuZXQpKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjb25zdGFudHM2LlRZUEVTW3N1Ym5ldF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICdHbG9iYWwgdW5pY2FzdCc7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybiB0aGUgYml0cyBpbiB0aGUgZ2l2ZW4gcmFuZ2UgYXMgYSBCaWdJbnRcbiAgICAgKiBAbWVtYmVyb2YgQWRkcmVzczZcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAcmV0dXJucyB7YmlnaW50fVxuICAgICAqL1xuICAgIGdldEJpdHMoc3RhcnQsIGVuZCkge1xuICAgICAgICByZXR1cm4gQmlnSW50KGAwYiR7dGhpcy5nZXRCaXRzQmFzZTIoc3RhcnQsIGVuZCl9YCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybiB0aGUgYml0cyBpbiB0aGUgZ2l2ZW4gcmFuZ2UgYXMgYSBiYXNlLTIgc3RyaW5nXG4gICAgICogQG1lbWJlcm9mIEFkZHJlc3M2XG4gICAgICogQGluc3RhbmNlXG4gICAgICogQHJldHVybnMge1N0cmluZ31cbiAgICAgKi9cbiAgICBnZXRCaXRzQmFzZTIoc3RhcnQsIGVuZCkge1xuICAgICAgICByZXR1cm4gdGhpcy5iaW5hcnlaZXJvUGFkKCkuc2xpY2Uoc3RhcnQsIGVuZCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybiB0aGUgYml0cyBpbiB0aGUgZ2l2ZW4gcmFuZ2UgYXMgYSBiYXNlLTE2IHN0cmluZ1xuICAgICAqIEBtZW1iZXJvZiBBZGRyZXNzNlxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEByZXR1cm5zIHtTdHJpbmd9XG4gICAgICovXG4gICAgZ2V0Qml0c0Jhc2UxNihzdGFydCwgZW5kKSB7XG4gICAgICAgIGNvbnN0IGxlbmd0aCA9IGVuZCAtIHN0YXJ0O1xuICAgICAgICBpZiAobGVuZ3RoICUgNCAhPT0gMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdMZW5ndGggb2YgYml0cyB0byByZXRyaWV2ZSBtdXN0IGJlIGRpdmlzaWJsZSBieSBmb3VyJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0Qml0cyhzdGFydCwgZW5kKVxuICAgICAgICAgICAgLnRvU3RyaW5nKDE2KVxuICAgICAgICAgICAgLnBhZFN0YXJ0KGxlbmd0aCAvIDQsICcwJyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybiB0aGUgYml0cyB0aGF0IGFyZSBzZXQgcGFzdCB0aGUgc3VibmV0IG1hc2sgbGVuZ3RoXG4gICAgICogQG1lbWJlcm9mIEFkZHJlc3M2XG4gICAgICogQGluc3RhbmNlXG4gICAgICogQHJldHVybnMge1N0cmluZ31cbiAgICAgKi9cbiAgICBnZXRCaXRzUGFzdFN1Ym5ldCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0Qml0c0Jhc2UyKHRoaXMuc3VibmV0TWFzaywgY29uc3RhbnRzNi5CSVRTKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJuIHRoZSByZXZlcnNlZCBpcDYuYXJwYSBmb3JtIG9mIHRoZSBhZGRyZXNzXG4gICAgICogQG1lbWJlcm9mIEFkZHJlc3M2XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IG9wdGlvbnMub21pdFN1ZmZpeCAtIG9taXQgdGhlIFwiaXA2LmFycGFcIiBzdWZmaXhcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfVxuICAgICAqL1xuICAgIHJldmVyc2VGb3JtKG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKCFvcHRpb25zKSB7XG4gICAgICAgICAgICBvcHRpb25zID0ge307XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY2hhcmFjdGVycyA9IE1hdGguZmxvb3IodGhpcy5zdWJuZXRNYXNrIC8gNCk7XG4gICAgICAgIGNvbnN0IHJldmVyc2VkID0gdGhpcy5jYW5vbmljYWxGb3JtKClcbiAgICAgICAgICAgIC5yZXBsYWNlKC86L2csICcnKVxuICAgICAgICAgICAgLnNwbGl0KCcnKVxuICAgICAgICAgICAgLnNsaWNlKDAsIGNoYXJhY3RlcnMpXG4gICAgICAgICAgICAucmV2ZXJzZSgpXG4gICAgICAgICAgICAuam9pbignLicpO1xuICAgICAgICBpZiAoY2hhcmFjdGVycyA+IDApIHtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLm9taXRTdWZmaXgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmV2ZXJzZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYCR7cmV2ZXJzZWR9LmlwNi5hcnBhLmA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnMub21pdFN1ZmZpeCkge1xuICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAnaXA2LmFycGEuJztcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJuIHRoZSBjb3JyZWN0IGZvcm0gb2YgdGhlIGFkZHJlc3NcbiAgICAgKiBAbWVtYmVyb2YgQWRkcmVzczZcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfVxuICAgICAqL1xuICAgIGNvcnJlY3RGb3JtKCkge1xuICAgICAgICBsZXQgaTtcbiAgICAgICAgbGV0IGdyb3VwcyA9IFtdO1xuICAgICAgICBsZXQgemVyb0NvdW50ZXIgPSAwO1xuICAgICAgICBjb25zdCB6ZXJvZXMgPSBbXTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHRoaXMucGFyc2VkQWRkcmVzcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBwYXJzZUludCh0aGlzLnBhcnNlZEFkZHJlc3NbaV0sIDE2KTtcbiAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHplcm9Db3VudGVyKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodmFsdWUgIT09IDAgJiYgemVyb0NvdW50ZXIgPiAwKSB7XG4gICAgICAgICAgICAgICAgaWYgKHplcm9Db3VudGVyID4gMSkge1xuICAgICAgICAgICAgICAgICAgICB6ZXJvZXMucHVzaChbaSAtIHplcm9Db3VudGVyLCBpIC0gMV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB6ZXJvQ291bnRlciA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gRG8gd2UgZW5kIHdpdGggYSBzdHJpbmcgb2YgemVyb2VzP1xuICAgICAgICBpZiAoemVyb0NvdW50ZXIgPiAxKSB7XG4gICAgICAgICAgICB6ZXJvZXMucHVzaChbdGhpcy5wYXJzZWRBZGRyZXNzLmxlbmd0aCAtIHplcm9Db3VudGVyLCB0aGlzLnBhcnNlZEFkZHJlc3MubGVuZ3RoIC0gMV0pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHplcm9MZW5ndGhzID0gemVyb2VzLm1hcCgobikgPT4gblsxXSAtIG5bMF0gKyAxKTtcbiAgICAgICAgaWYgKHplcm9lcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBjb25zdCBpbmRleCA9IHplcm9MZW5ndGhzLmluZGV4T2YoTWF0aC5tYXgoLi4uemVyb0xlbmd0aHMpKTtcbiAgICAgICAgICAgIGdyb3VwcyA9IGNvbXBhY3QodGhpcy5wYXJzZWRBZGRyZXNzLCB6ZXJvZXNbaW5kZXhdKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGdyb3VwcyA9IHRoaXMucGFyc2VkQWRkcmVzcztcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgZ3JvdXBzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoZ3JvdXBzW2ldICE9PSAnY29tcGFjdCcpIHtcbiAgICAgICAgICAgICAgICBncm91cHNbaV0gPSBwYXJzZUludChncm91cHNbaV0sIDE2KS50b1N0cmluZygxNik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGNvcnJlY3QgPSBncm91cHMuam9pbignOicpO1xuICAgICAgICBjb3JyZWN0ID0gY29ycmVjdC5yZXBsYWNlKC9eY29tcGFjdCQvLCAnOjonKTtcbiAgICAgICAgY29ycmVjdCA9IGNvcnJlY3QucmVwbGFjZSgvKF5jb21wYWN0KXwoY29tcGFjdCQpLywgJzonKTtcbiAgICAgICAgY29ycmVjdCA9IGNvcnJlY3QucmVwbGFjZSgvY29tcGFjdC8sICcnKTtcbiAgICAgICAgcmV0dXJuIGNvcnJlY3Q7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybiBhIHplcm8tcGFkZGVkIGJhc2UtMiBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIGFkZHJlc3NcbiAgICAgKiBAbWVtYmVyb2YgQWRkcmVzczZcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfVxuICAgICAqIEBleGFtcGxlXG4gICAgICogdmFyIGFkZHJlc3MgPSBuZXcgQWRkcmVzczYoJzIwMDE6NDg2MDo0MDAxOjgwMzo6MTAxMScpO1xuICAgICAqIGFkZHJlc3MuYmluYXJ5WmVyb1BhZCgpO1xuICAgICAqIC8vICcwMDEwMDAwMDAwMDAwMDAxMDEwMDEwMDAwMTEwMDAwMDAxMDAwMDAwMDAwMDAwMDEwMDAwMTAwMDAwMDAwMDExXG4gICAgICogLy8gIDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDEwMDAwMDAwMTAwMDEnXG4gICAgICovXG4gICAgYmluYXJ5WmVyb1BhZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYmlnSW50KCkudG9TdHJpbmcoMikucGFkU3RhcnQoY29uc3RhbnRzNi5CSVRTLCAnMCcpO1xuICAgIH1cbiAgICAvLyBUT0RPOiBJbXByb3ZlIHRoZSBzZW1hbnRpY3Mgb2YgdGhpcyBoZWxwZXIgZnVuY3Rpb25cbiAgICBwYXJzZTRpbjYoYWRkcmVzcykge1xuICAgICAgICBjb25zdCBncm91cHMgPSBhZGRyZXNzLnNwbGl0KCc6Jyk7XG4gICAgICAgIGNvbnN0IGxhc3RHcm91cCA9IGdyb3Vwcy5zbGljZSgtMSlbMF07XG4gICAgICAgIGNvbnN0IGFkZHJlc3M0ID0gbGFzdEdyb3VwLm1hdGNoKGNvbnN0YW50czQuUkVfQUREUkVTUyk7XG4gICAgICAgIGlmIChhZGRyZXNzNCkge1xuICAgICAgICAgICAgdGhpcy5wYXJzZWRBZGRyZXNzNCA9IGFkZHJlc3M0WzBdO1xuICAgICAgICAgICAgdGhpcy5hZGRyZXNzNCA9IG5ldyBpcHY0XzEuQWRkcmVzczQodGhpcy5wYXJzZWRBZGRyZXNzNCk7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuYWRkcmVzczQuZ3JvdXBzOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoL14wWzAtOV0rLy50ZXN0KHRoaXMuYWRkcmVzczQucGFyc2VkQWRkcmVzc1tpXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IGFkZHJlc3NfZXJyb3JfMS5BZGRyZXNzRXJyb3IoXCJJUHY0IGFkZHJlc3NlcyBjYW4ndCBoYXZlIGxlYWRpbmcgemVyb2VzLlwiLCBhZGRyZXNzLnJlcGxhY2UoY29uc3RhbnRzNC5SRV9BRERSRVNTLCB0aGlzLmFkZHJlc3M0LnBhcnNlZEFkZHJlc3MubWFwKHNwYW5MZWFkaW5nWmVyb2VzNCkuam9pbignLicpKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy52NCA9IHRydWU7XG4gICAgICAgICAgICBncm91cHNbZ3JvdXBzLmxlbmd0aCAtIDFdID0gdGhpcy5hZGRyZXNzNC50b0dyb3VwNigpO1xuICAgICAgICAgICAgYWRkcmVzcyA9IGdyb3Vwcy5qb2luKCc6Jyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFkZHJlc3M7XG4gICAgfVxuICAgIC8vIFRPRE86IE1ha2UgcHJpdmF0ZT9cbiAgICBwYXJzZShhZGRyZXNzKSB7XG4gICAgICAgIGFkZHJlc3MgPSB0aGlzLnBhcnNlNGluNihhZGRyZXNzKTtcbiAgICAgICAgY29uc3QgYmFkQ2hhcmFjdGVycyA9IGFkZHJlc3MubWF0Y2goY29uc3RhbnRzNi5SRV9CQURfQ0hBUkFDVEVSUyk7XG4gICAgICAgIGlmIChiYWRDaGFyYWN0ZXJzKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgYWRkcmVzc19lcnJvcl8xLkFkZHJlc3NFcnJvcihgQmFkIGNoYXJhY3RlciR7YmFkQ2hhcmFjdGVycy5sZW5ndGggPiAxID8gJ3MnIDogJyd9IGRldGVjdGVkIGluIGFkZHJlc3M6ICR7YmFkQ2hhcmFjdGVycy5qb2luKCcnKX1gLCBhZGRyZXNzLnJlcGxhY2UoY29uc3RhbnRzNi5SRV9CQURfQ0hBUkFDVEVSUywgJzxzcGFuIGNsYXNzPVwicGFyc2UtZXJyb3JcIj4kMTwvc3Bhbj4nKSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYmFkQWRkcmVzcyA9IGFkZHJlc3MubWF0Y2goY29uc3RhbnRzNi5SRV9CQURfQUREUkVTUyk7XG4gICAgICAgIGlmIChiYWRBZGRyZXNzKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgYWRkcmVzc19lcnJvcl8xLkFkZHJlc3NFcnJvcihgQWRkcmVzcyBmYWlsZWQgcmVnZXg6ICR7YmFkQWRkcmVzcy5qb2luKCcnKX1gLCBhZGRyZXNzLnJlcGxhY2UoY29uc3RhbnRzNi5SRV9CQURfQUREUkVTUywgJzxzcGFuIGNsYXNzPVwicGFyc2UtZXJyb3JcIj4kMTwvc3Bhbj4nKSk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGdyb3VwcyA9IFtdO1xuICAgICAgICBjb25zdCBoYWx2ZXMgPSBhZGRyZXNzLnNwbGl0KCc6OicpO1xuICAgICAgICBpZiAoaGFsdmVzLmxlbmd0aCA9PT0gMikge1xuICAgICAgICAgICAgbGV0IGZpcnN0ID0gaGFsdmVzWzBdLnNwbGl0KCc6Jyk7XG4gICAgICAgICAgICBsZXQgbGFzdCA9IGhhbHZlc1sxXS5zcGxpdCgnOicpO1xuICAgICAgICAgICAgaWYgKGZpcnN0Lmxlbmd0aCA9PT0gMSAmJiBmaXJzdFswXSA9PT0gJycpIHtcbiAgICAgICAgICAgICAgICBmaXJzdCA9IFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGxhc3QubGVuZ3RoID09PSAxICYmIGxhc3RbMF0gPT09ICcnKSB7XG4gICAgICAgICAgICAgICAgbGFzdCA9IFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVtYWluaW5nID0gdGhpcy5ncm91cHMgLSAoZmlyc3QubGVuZ3RoICsgbGFzdC5sZW5ndGgpO1xuICAgICAgICAgICAgaWYgKCFyZW1haW5pbmcpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgYWRkcmVzc19lcnJvcl8xLkFkZHJlc3NFcnJvcignRXJyb3IgcGFyc2luZyBncm91cHMnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuZWxpZGVkR3JvdXBzID0gcmVtYWluaW5nO1xuICAgICAgICAgICAgdGhpcy5lbGlzaW9uQmVnaW4gPSBmaXJzdC5sZW5ndGg7XG4gICAgICAgICAgICB0aGlzLmVsaXNpb25FbmQgPSBmaXJzdC5sZW5ndGggKyB0aGlzLmVsaWRlZEdyb3VwcztcbiAgICAgICAgICAgIGdyb3VwcyA9IGdyb3Vwcy5jb25jYXQoZmlyc3QpO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByZW1haW5pbmc7IGkrKykge1xuICAgICAgICAgICAgICAgIGdyb3Vwcy5wdXNoKCcwJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBncm91cHMgPSBncm91cHMuY29uY2F0KGxhc3QpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGhhbHZlcy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIGdyb3VwcyA9IGFkZHJlc3Muc3BsaXQoJzonKTtcbiAgICAgICAgICAgIHRoaXMuZWxpZGVkR3JvdXBzID0gMDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBhZGRyZXNzX2Vycm9yXzEuQWRkcmVzc0Vycm9yKCdUb28gbWFueSA6OiBncm91cHMgZm91bmQnKTtcbiAgICAgICAgfVxuICAgICAgICBncm91cHMgPSBncm91cHMubWFwKChncm91cCkgPT4gcGFyc2VJbnQoZ3JvdXAsIDE2KS50b1N0cmluZygxNikpO1xuICAgICAgICBpZiAoZ3JvdXBzLmxlbmd0aCAhPT0gdGhpcy5ncm91cHMpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBhZGRyZXNzX2Vycm9yXzEuQWRkcmVzc0Vycm9yKCdJbmNvcnJlY3QgbnVtYmVyIG9mIGdyb3VwcyBmb3VuZCcpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBncm91cHM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybiB0aGUgY2Fub25pY2FsIGZvcm0gb2YgdGhlIGFkZHJlc3NcbiAgICAgKiBAbWVtYmVyb2YgQWRkcmVzczZcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfVxuICAgICAqL1xuICAgIGNhbm9uaWNhbEZvcm0oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlZEFkZHJlc3MubWFwKHBhZGRlZEhleCkuam9pbignOicpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gdGhlIGRlY2ltYWwgZm9ybSBvZiB0aGUgYWRkcmVzc1xuICAgICAqIEBtZW1iZXJvZiBBZGRyZXNzNlxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEByZXR1cm5zIHtTdHJpbmd9XG4gICAgICovXG4gICAgZGVjaW1hbCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VkQWRkcmVzcy5tYXAoKG4pID0+IHBhcnNlSW50KG4sIDE2KS50b1N0cmluZygxMCkucGFkU3RhcnQoNSwgJzAnKSkuam9pbignOicpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gdGhlIGFkZHJlc3MgYXMgYSBCaWdJbnRcbiAgICAgKiBAbWVtYmVyb2YgQWRkcmVzczZcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAcmV0dXJucyB7YmlnaW50fVxuICAgICAqL1xuICAgIGJpZ0ludCgpIHtcbiAgICAgICAgcmV0dXJuIEJpZ0ludChgMHgke3RoaXMucGFyc2VkQWRkcmVzcy5tYXAocGFkZGVkSGV4KS5qb2luKCcnKX1gKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJuIHRoZSBsYXN0IHR3byBncm91cHMgb2YgdGhpcyBhZGRyZXNzIGFzIGFuIElQdjQgYWRkcmVzcyBzdHJpbmdcbiAgICAgKiBAbWVtYmVyb2YgQWRkcmVzczZcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAcmV0dXJucyB7QWRkcmVzczR9XG4gICAgICogQGV4YW1wbGVcbiAgICAgKiB2YXIgYWRkcmVzcyA9IG5ldyBBZGRyZXNzNignMjAwMTo0ODYwOjQwMDE6OjE4MjU6YmYxMScpO1xuICAgICAqIGFkZHJlc3MudG80KCkuY29ycmVjdEZvcm0oKTsgLy8gJzI0LjM3LjE5MS4xNydcbiAgICAgKi9cbiAgICB0bzQoKSB7XG4gICAgICAgIGNvbnN0IGJpbmFyeSA9IHRoaXMuYmluYXJ5WmVyb1BhZCgpLnNwbGl0KCcnKTtcbiAgICAgICAgcmV0dXJuIGlwdjRfMS5BZGRyZXNzNC5mcm9tSGV4KEJpZ0ludChgMGIke2JpbmFyeS5zbGljZSg5NiwgMTI4KS5qb2luKCcnKX1gKS50b1N0cmluZygxNikpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gdGhlIHY0LWluLXY2IGZvcm0gb2YgdGhlIGFkZHJlc3NcbiAgICAgKiBAbWVtYmVyb2YgQWRkcmVzczZcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfVxuICAgICAqL1xuICAgIHRvNGluNigpIHtcbiAgICAgICAgY29uc3QgYWRkcmVzczQgPSB0aGlzLnRvNCgpO1xuICAgICAgICBjb25zdCBhZGRyZXNzNiA9IG5ldyBBZGRyZXNzNih0aGlzLnBhcnNlZEFkZHJlc3Muc2xpY2UoMCwgNikuam9pbignOicpLCA2KTtcbiAgICAgICAgY29uc3QgY29ycmVjdCA9IGFkZHJlc3M2LmNvcnJlY3RGb3JtKCk7XG4gICAgICAgIGxldCBpbmZpeCA9ICcnO1xuICAgICAgICBpZiAoIS86JC8udGVzdChjb3JyZWN0KSkge1xuICAgICAgICAgICAgaW5maXggPSAnOic7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvcnJlY3QgKyBpbmZpeCArIGFkZHJlc3M0LmFkZHJlc3M7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybiBhbiBvYmplY3QgY29udGFpbmluZyB0aGUgVGVyZWRvIHByb3BlcnRpZXMgb2YgdGhlIGFkZHJlc3NcbiAgICAgKiBAbWVtYmVyb2YgQWRkcmVzczZcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgICAqL1xuICAgIGluc3BlY3RUZXJlZG8oKSB7XG4gICAgICAgIC8qXG4gICAgICAgIC0gQml0cyAwIHRvIDMxIGFyZSBzZXQgdG8gdGhlIFRlcmVkbyBwcmVmaXggKG5vcm1hbGx5IDIwMDE6MDAwMDo6LzMyKS5cbiAgICAgICAgLSBCaXRzIDMyIHRvIDYzIGVtYmVkIHRoZSBwcmltYXJ5IElQdjQgYWRkcmVzcyBvZiB0aGUgVGVyZWRvIHNlcnZlciB0aGF0XG4gICAgICAgICAgaXMgdXNlZC5cbiAgICAgICAgLSBCaXRzIDY0IHRvIDc5IGNhbiBiZSB1c2VkIHRvIGRlZmluZSBzb21lIGZsYWdzLiBDdXJyZW50bHkgb25seSB0aGVcbiAgICAgICAgICBoaWdoZXIgb3JkZXIgYml0IGlzIHVzZWQ7IGl0IGlzIHNldCB0byAxIGlmIHRoZSBUZXJlZG8gY2xpZW50IGlzXG4gICAgICAgICAgbG9jYXRlZCBiZWhpbmQgYSBjb25lIE5BVCwgMCBvdGhlcndpc2UuIEZvciBNaWNyb3NvZnQncyBXaW5kb3dzIFZpc3RhXG4gICAgICAgICAgYW5kIFdpbmRvd3MgU2VydmVyIDIwMDggaW1wbGVtZW50YXRpb25zLCBtb3JlIGJpdHMgYXJlIHVzZWQuIEluIHRob3NlXG4gICAgICAgICAgaW1wbGVtZW50YXRpb25zLCB0aGUgZm9ybWF0IGZvciB0aGVzZSAxNiBiaXRzIGlzIFwiQ1JBQUFBVUcgQUFBQUFBQUFcIixcbiAgICAgICAgICB3aGVyZSBcIkNcIiByZW1haW5zIHRoZSBcIkNvbmVcIiBmbGFnLiBUaGUgXCJSXCIgYml0IGlzIHJlc2VydmVkIGZvciBmdXR1cmVcbiAgICAgICAgICB1c2UuIFRoZSBcIlVcIiBiaXQgaXMgZm9yIHRoZSBVbml2ZXJzYWwvTG9jYWwgZmxhZyAoc2V0IHRvIDApLiBUaGUgXCJHXCIgYml0XG4gICAgICAgICAgaXMgSW5kaXZpZHVhbC9Hcm91cCBmbGFnIChzZXQgdG8gMCkuIFRoZSBBIGJpdHMgYXJlIHNldCB0byBhIDEyLWJpdFxuICAgICAgICAgIHJhbmRvbWx5IGdlbmVyYXRlZCBudW1iZXIgY2hvc2VuIGJ5IHRoZSBUZXJlZG8gY2xpZW50IHRvIGludHJvZHVjZVxuICAgICAgICAgIGFkZGl0aW9uYWwgcHJvdGVjdGlvbiBmb3IgdGhlIFRlcmVkbyBub2RlIGFnYWluc3QgSVB2Ni1iYXNlZCBzY2FubmluZ1xuICAgICAgICAgIGF0dGFja3MuXG4gICAgICAgIC0gQml0cyA4MCB0byA5NSBjb250YWlucyB0aGUgb2JmdXNjYXRlZCBVRFAgcG9ydCBudW1iZXIuIFRoaXMgaXMgdGhlXG4gICAgICAgICAgcG9ydCBudW1iZXIgdGhhdCBpcyBtYXBwZWQgYnkgdGhlIE5BVCB0byB0aGUgVGVyZWRvIGNsaWVudCB3aXRoIGFsbFxuICAgICAgICAgIGJpdHMgaW52ZXJ0ZWQuXG4gICAgICAgIC0gQml0cyA5NiB0byAxMjcgY29udGFpbnMgdGhlIG9iZnVzY2F0ZWQgSVB2NCBhZGRyZXNzLiBUaGlzIGlzIHRoZVxuICAgICAgICAgIHB1YmxpYyBJUHY0IGFkZHJlc3Mgb2YgdGhlIE5BVCB3aXRoIGFsbCBiaXRzIGludmVydGVkLlxuICAgICAgICAqL1xuICAgICAgICBjb25zdCBwcmVmaXggPSB0aGlzLmdldEJpdHNCYXNlMTYoMCwgMzIpO1xuICAgICAgICBjb25zdCBiaXRzRm9yVWRwUG9ydCA9IHRoaXMuZ2V0Qml0cyg4MCwgOTYpO1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tYml0d2lzZVxuICAgICAgICBjb25zdCB1ZHBQb3J0ID0gKGJpdHNGb3JVZHBQb3J0IF4gQmlnSW50KCcweGZmZmYnKSkudG9TdHJpbmcoKTtcbiAgICAgICAgY29uc3Qgc2VydmVyNCA9IGlwdjRfMS5BZGRyZXNzNC5mcm9tSGV4KHRoaXMuZ2V0Qml0c0Jhc2UxNigzMiwgNjQpKTtcbiAgICAgICAgY29uc3QgYml0c0ZvckNsaWVudDQgPSB0aGlzLmdldEJpdHMoOTYsIDEyOCk7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1iaXR3aXNlXG4gICAgICAgIGNvbnN0IGNsaWVudDQgPSBpcHY0XzEuQWRkcmVzczQuZnJvbUhleCgoYml0c0ZvckNsaWVudDQgXiBCaWdJbnQoJzB4ZmZmZmZmZmYnKSkudG9TdHJpbmcoMTYpKTtcbiAgICAgICAgY29uc3QgZmxhZ3NCYXNlMiA9IHRoaXMuZ2V0Qml0c0Jhc2UyKDY0LCA4MCk7XG4gICAgICAgIGNvbnN0IGNvbmVOYXQgPSAoMCwgY29tbW9uXzEudGVzdEJpdCkoZmxhZ3NCYXNlMiwgMTUpO1xuICAgICAgICBjb25zdCByZXNlcnZlZCA9ICgwLCBjb21tb25fMS50ZXN0Qml0KShmbGFnc0Jhc2UyLCAxNCk7XG4gICAgICAgIGNvbnN0IGdyb3VwSW5kaXZpZHVhbCA9ICgwLCBjb21tb25fMS50ZXN0Qml0KShmbGFnc0Jhc2UyLCA4KTtcbiAgICAgICAgY29uc3QgdW5pdmVyc2FsTG9jYWwgPSAoMCwgY29tbW9uXzEudGVzdEJpdCkoZmxhZ3NCYXNlMiwgOSk7XG4gICAgICAgIGNvbnN0IG5vbmNlID0gQmlnSW50KGAwYiR7ZmxhZ3NCYXNlMi5zbGljZSgyLCA2KSArIGZsYWdzQmFzZTIuc2xpY2UoOCwgMTYpfWApLnRvU3RyaW5nKDEwKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHByZWZpeDogYCR7cHJlZml4LnNsaWNlKDAsIDQpfToke3ByZWZpeC5zbGljZSg0LCA4KX1gLFxuICAgICAgICAgICAgc2VydmVyNDogc2VydmVyNC5hZGRyZXNzLFxuICAgICAgICAgICAgY2xpZW50NDogY2xpZW50NC5hZGRyZXNzLFxuICAgICAgICAgICAgZmxhZ3M6IGZsYWdzQmFzZTIsXG4gICAgICAgICAgICBjb25lTmF0LFxuICAgICAgICAgICAgbWljcm9zb2Z0OiB7XG4gICAgICAgICAgICAgICAgcmVzZXJ2ZWQsXG4gICAgICAgICAgICAgICAgdW5pdmVyc2FsTG9jYWwsXG4gICAgICAgICAgICAgICAgZ3JvdXBJbmRpdmlkdWFsLFxuICAgICAgICAgICAgICAgIG5vbmNlLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHVkcFBvcnQsXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybiBhbiBvYmplY3QgY29udGFpbmluZyB0aGUgNnRvNCBwcm9wZXJ0aWVzIG9mIHRoZSBhZGRyZXNzXG4gICAgICogQG1lbWJlcm9mIEFkZHJlc3M2XG4gICAgICogQGluc3RhbmNlXG4gICAgICogQHJldHVybnMge09iamVjdH1cbiAgICAgKi9cbiAgICBpbnNwZWN0NnRvNCgpIHtcbiAgICAgICAgLypcbiAgICAgICAgLSBCaXRzIDAgdG8gMTUgYXJlIHNldCB0byB0aGUgNnRvNCBwcmVmaXggKDIwMDI6Oi8xNikuXG4gICAgICAgIC0gQml0cyAxNiB0byA0OCBlbWJlZCB0aGUgSVB2NCBhZGRyZXNzIG9mIHRoZSA2dG80IGdhdGV3YXkgdGhhdCBpcyB1c2VkLlxuICAgICAgICAqL1xuICAgICAgICBjb25zdCBwcmVmaXggPSB0aGlzLmdldEJpdHNCYXNlMTYoMCwgMTYpO1xuICAgICAgICBjb25zdCBnYXRld2F5ID0gaXB2NF8xLkFkZHJlc3M0LmZyb21IZXgodGhpcy5nZXRCaXRzQmFzZTE2KDE2LCA0OCkpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcHJlZml4OiBwcmVmaXguc2xpY2UoMCwgNCksXG4gICAgICAgICAgICBnYXRld2F5OiBnYXRld2F5LmFkZHJlc3MsXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybiBhIHY2IDZ0bzQgYWRkcmVzcyBmcm9tIGEgdjYgdjRpbnY2IGFkZHJlc3NcbiAgICAgKiBAbWVtYmVyb2YgQWRkcmVzczZcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAcmV0dXJucyB7QWRkcmVzczZ9XG4gICAgICovXG4gICAgdG82dG80KCkge1xuICAgICAgICBpZiAoIXRoaXMuaXM0KCkpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGFkZHI2dG80ID0gW1xuICAgICAgICAgICAgJzIwMDInLFxuICAgICAgICAgICAgdGhpcy5nZXRCaXRzQmFzZTE2KDk2LCAxMTIpLFxuICAgICAgICAgICAgdGhpcy5nZXRCaXRzQmFzZTE2KDExMiwgMTI4KSxcbiAgICAgICAgICAgICcnLFxuICAgICAgICAgICAgJy8xNicsXG4gICAgICAgIF0uam9pbignOicpO1xuICAgICAgICByZXR1cm4gbmV3IEFkZHJlc3M2KGFkZHI2dG80KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJuIGEgYnl0ZSBhcnJheVxuICAgICAqIEBtZW1iZXJvZiBBZGRyZXNzNlxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEByZXR1cm5zIHtBcnJheX1cbiAgICAgKi9cbiAgICB0b0J5dGVBcnJheSgpIHtcbiAgICAgICAgY29uc3QgdmFsdWVXaXRob3V0UGFkZGluZyA9IHRoaXMuYmlnSW50KCkudG9TdHJpbmcoMTYpO1xuICAgICAgICBjb25zdCBsZWFkaW5nUGFkID0gJzAnLnJlcGVhdCh2YWx1ZVdpdGhvdXRQYWRkaW5nLmxlbmd0aCAlIDIpO1xuICAgICAgICBjb25zdCB2YWx1ZSA9IGAke2xlYWRpbmdQYWR9JHt2YWx1ZVdpdGhvdXRQYWRkaW5nfWA7XG4gICAgICAgIGNvbnN0IGJ5dGVzID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBsZW5ndGggPSB2YWx1ZS5sZW5ndGg7IGkgPCBsZW5ndGg7IGkgKz0gMikge1xuICAgICAgICAgICAgYnl0ZXMucHVzaChwYXJzZUludCh2YWx1ZS5zdWJzdHJpbmcoaSwgaSArIDIpLCAxNikpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBieXRlcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJuIGFuIHVuc2lnbmVkIGJ5dGUgYXJyYXlcbiAgICAgKiBAbWVtYmVyb2YgQWRkcmVzczZcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9XG4gICAgICovXG4gICAgdG9VbnNpZ25lZEJ5dGVBcnJheSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudG9CeXRlQXJyYXkoKS5tYXAodW5zaWduQnl0ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbnZlcnQgYSBieXRlIGFycmF5IHRvIGFuIEFkZHJlc3M2IG9iamVjdFxuICAgICAqIEBtZW1iZXJvZiBBZGRyZXNzNlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAcmV0dXJucyB7QWRkcmVzczZ9XG4gICAgICovXG4gICAgc3RhdGljIGZyb21CeXRlQXJyYXkoYnl0ZXMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZnJvbVVuc2lnbmVkQnl0ZUFycmF5KGJ5dGVzLm1hcCh1bnNpZ25CeXRlKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbnZlcnQgYW4gdW5zaWduZWQgYnl0ZSBhcnJheSB0byBhbiBBZGRyZXNzNiBvYmplY3RcbiAgICAgKiBAbWVtYmVyb2YgQWRkcmVzczZcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHJldHVybnMge0FkZHJlc3M2fVxuICAgICAqL1xuICAgIHN0YXRpYyBmcm9tVW5zaWduZWRCeXRlQXJyYXkoYnl0ZXMpIHtcbiAgICAgICAgY29uc3QgQllURV9NQVggPSBCaWdJbnQoJzI1NicpO1xuICAgICAgICBsZXQgcmVzdWx0ID0gQmlnSW50KCcwJyk7XG4gICAgICAgIGxldCBtdWx0aXBsaWVyID0gQmlnSW50KCcxJyk7XG4gICAgICAgIGZvciAobGV0IGkgPSBieXRlcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgcmVzdWx0ICs9IG11bHRpcGxpZXIgKiBCaWdJbnQoYnl0ZXNbaV0udG9TdHJpbmcoMTApKTtcbiAgICAgICAgICAgIG11bHRpcGxpZXIgKj0gQllURV9NQVg7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIEFkZHJlc3M2LmZyb21CaWdJbnQocmVzdWx0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0cnVlIGlmIHRoZSBhZGRyZXNzIGlzIGluIHRoZSBjYW5vbmljYWwgZm9ybSwgZmFsc2Ugb3RoZXJ3aXNlXG4gICAgICogQG1lbWJlcm9mIEFkZHJlc3M2XG4gICAgICogQGluc3RhbmNlXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG4gICAgaXNDYW5vbmljYWwoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFkZHJlc3NNaW51c1N1ZmZpeCA9PT0gdGhpcy5jYW5vbmljYWxGb3JtKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgYWRkcmVzcyBpcyBhIGxpbmsgbG9jYWwgYWRkcmVzcywgZmFsc2Ugb3RoZXJ3aXNlXG4gICAgICogQG1lbWJlcm9mIEFkZHJlc3M2XG4gICAgICogQGluc3RhbmNlXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG4gICAgaXNMaW5rTG9jYWwoKSB7XG4gICAgICAgIC8vIFplcm9lcyBhcmUgcmVxdWlyZWQsIGkuZS4gd2UgY2FuJ3QgY2hlY2sgaXNJblN1Ym5ldCB3aXRoICdmZTgwOjovMTAnXG4gICAgICAgIGlmICh0aGlzLmdldEJpdHNCYXNlMigwLCA2NCkgPT09XG4gICAgICAgICAgICAnMTExMTExMTAxMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCcpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0cnVlIGlmIHRoZSBhZGRyZXNzIGlzIGEgbXVsdGljYXN0IGFkZHJlc3MsIGZhbHNlIG90aGVyd2lzZVxuICAgICAqIEBtZW1iZXJvZiBBZGRyZXNzNlxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICAgIGlzTXVsdGljYXN0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRUeXBlKCkgPT09ICdNdWx0aWNhc3QnO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIGFkZHJlc3MgaXMgYSB2NC1pbi12NiBhZGRyZXNzLCBmYWxzZSBvdGhlcndpc2VcbiAgICAgKiBAbWVtYmVyb2YgQWRkcmVzczZcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBpczQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnY0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIGFkZHJlc3MgaXMgYSBUZXJlZG8gYWRkcmVzcywgZmFsc2Ugb3RoZXJ3aXNlXG4gICAgICogQG1lbWJlcm9mIEFkZHJlc3M2XG4gICAgICogQGluc3RhbmNlXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG4gICAgaXNUZXJlZG8oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmlzSW5TdWJuZXQobmV3IEFkZHJlc3M2KCcyMDAxOjovMzInKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgYWRkcmVzcyBpcyBhIDZ0bzQgYWRkcmVzcywgZmFsc2Ugb3RoZXJ3aXNlXG4gICAgICogQG1lbWJlcm9mIEFkZHJlc3M2XG4gICAgICogQGluc3RhbmNlXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG4gICAgaXM2dG80KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pc0luU3VibmV0KG5ldyBBZGRyZXNzNignMjAwMjo6LzE2JykpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIGFkZHJlc3MgaXMgYSBsb29wYmFjayBhZGRyZXNzLCBmYWxzZSBvdGhlcndpc2VcbiAgICAgKiBAbWVtYmVyb2YgQWRkcmVzczZcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBpc0xvb3BiYWNrKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRUeXBlKCkgPT09ICdMb29wYmFjayc7XG4gICAgfVxuICAgIC8vICNlbmRyZWdpb25cbiAgICAvLyAjcmVnaW9uIEhUTUxcbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfSB0aGUgYWRkcmVzcyBpbiBsaW5rIGZvcm0gd2l0aCBhIGRlZmF1bHQgcG9ydCBvZiA4MFxuICAgICAqL1xuICAgIGhyZWYob3B0aW9uYWxQb3J0KSB7XG4gICAgICAgIGlmIChvcHRpb25hbFBvcnQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgb3B0aW9uYWxQb3J0ID0gJyc7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBvcHRpb25hbFBvcnQgPSBgOiR7b3B0aW9uYWxQb3J0fWA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGBodHRwOi8vWyR7dGhpcy5jb3JyZWN0Rm9ybSgpfV0ke29wdGlvbmFsUG9ydH0vYDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge1N0cmluZ30gYSBsaW5rIHN1aXRhYmxlIGZvciBjb252ZXlpbmcgdGhlIGFkZHJlc3MgdmlhIGEgVVJMIGhhc2hcbiAgICAgKi9cbiAgICBsaW5rKG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKCFvcHRpb25zKSB7XG4gICAgICAgICAgICBvcHRpb25zID0ge307XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnMuY2xhc3NOYW1lID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIG9wdGlvbnMuY2xhc3NOYW1lID0gJyc7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnMucHJlZml4ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIG9wdGlvbnMucHJlZml4ID0gJy8jYWRkcmVzcz0nO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zLnY0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIG9wdGlvbnMudjQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgZm9ybUZ1bmN0aW9uID0gdGhpcy5jb3JyZWN0Rm9ybTtcbiAgICAgICAgaWYgKG9wdGlvbnMudjQpIHtcbiAgICAgICAgICAgIGZvcm1GdW5jdGlvbiA9IHRoaXMudG80aW42O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGZvcm0gPSBmb3JtRnVuY3Rpb24uY2FsbCh0aGlzKTtcbiAgICAgICAgaWYgKG9wdGlvbnMuY2xhc3NOYW1lKSB7XG4gICAgICAgICAgICByZXR1cm4gYDxhIGhyZWY9XCIke29wdGlvbnMucHJlZml4fSR7Zm9ybX1cIiBjbGFzcz1cIiR7b3B0aW9ucy5jbGFzc05hbWV9XCI+JHtmb3JtfTwvYT5gO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBgPGEgaHJlZj1cIiR7b3B0aW9ucy5wcmVmaXh9JHtmb3JtfVwiPiR7Zm9ybX08L2E+YDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR3JvdXBzIGFuIGFkZHJlc3NcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfVxuICAgICAqL1xuICAgIGdyb3VwKCkge1xuICAgICAgICBpZiAodGhpcy5lbGlkZWRHcm91cHMgPT09IDApIHtcbiAgICAgICAgICAgIC8vIFRoZSBzaW1wbGUgY2FzZVxuICAgICAgICAgICAgcmV0dXJuIGhlbHBlcnMuc2ltcGxlR3JvdXAodGhpcy5hZGRyZXNzKS5qb2luKCc6Jyk7XG4gICAgICAgIH1cbiAgICAgICAgYXNzZXJ0KHR5cGVvZiB0aGlzLmVsaWRlZEdyb3VwcyA9PT0gJ251bWJlcicpO1xuICAgICAgICBhc3NlcnQodHlwZW9mIHRoaXMuZWxpc2lvbkJlZ2luID09PSAnbnVtYmVyJyk7XG4gICAgICAgIC8vIFRoZSBlbGlkZWQgY2FzZVxuICAgICAgICBjb25zdCBvdXRwdXQgPSBbXTtcbiAgICAgICAgY29uc3QgW2xlZnQsIHJpZ2h0XSA9IHRoaXMuYWRkcmVzcy5zcGxpdCgnOjonKTtcbiAgICAgICAgaWYgKGxlZnQubGVuZ3RoKSB7XG4gICAgICAgICAgICBvdXRwdXQucHVzaCguLi5oZWxwZXJzLnNpbXBsZUdyb3VwKGxlZnQpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG91dHB1dC5wdXNoKCcnKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjbGFzc2VzID0gWydob3Zlci1ncm91cCddO1xuICAgICAgICBmb3IgKGxldCBpID0gdGhpcy5lbGlzaW9uQmVnaW47IGkgPCB0aGlzLmVsaXNpb25CZWdpbiArIHRoaXMuZWxpZGVkR3JvdXBzOyBpKyspIHtcbiAgICAgICAgICAgIGNsYXNzZXMucHVzaChgZ3JvdXAtJHtpfWApO1xuICAgICAgICB9XG4gICAgICAgIG91dHB1dC5wdXNoKGA8c3BhbiBjbGFzcz1cIiR7Y2xhc3Nlcy5qb2luKCcgJyl9XCI+PC9zcGFuPmApO1xuICAgICAgICBpZiAocmlnaHQubGVuZ3RoKSB7XG4gICAgICAgICAgICBvdXRwdXQucHVzaCguLi5oZWxwZXJzLnNpbXBsZUdyb3VwKHJpZ2h0LCB0aGlzLmVsaXNpb25FbmQpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG91dHB1dC5wdXNoKCcnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5pczQoKSkge1xuICAgICAgICAgICAgYXNzZXJ0KHRoaXMuYWRkcmVzczQgaW5zdGFuY2VvZiBpcHY0XzEuQWRkcmVzczQpO1xuICAgICAgICAgICAgb3V0cHV0LnBvcCgpO1xuICAgICAgICAgICAgb3V0cHV0LnB1c2godGhpcy5hZGRyZXNzNC5ncm91cEZvclY2KCkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvdXRwdXQuam9pbignOicpO1xuICAgIH1cbiAgICAvLyAjZW5kcmVnaW9uXG4gICAgLy8gI3JlZ2lvbiBSZWd1bGFyIGV4cHJlc3Npb25zXG4gICAgLyoqXG4gICAgICogR2VuZXJhdGUgYSByZWd1bGFyIGV4cHJlc3Npb24gc3RyaW5nIHRoYXQgY2FuIGJlIHVzZWQgdG8gZmluZCBvciB2YWxpZGF0ZVxuICAgICAqIGFsbCB2YXJpYXRpb25zIG9mIHRoaXMgYWRkcmVzc1xuICAgICAqIEBtZW1iZXJvZiBBZGRyZXNzNlxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gc3Vic3RyaW5nU2VhcmNoXG4gICAgICogQHJldHVybnMge3N0cmluZ31cbiAgICAgKi9cbiAgICByZWd1bGFyRXhwcmVzc2lvblN0cmluZyhzdWJzdHJpbmdTZWFyY2ggPSBmYWxzZSkge1xuICAgICAgICBsZXQgb3V0cHV0ID0gW107XG4gICAgICAgIC8vIFRPRE86IHJldmlzaXQgd2h5IHRoaXMgaXMgbmVjZXNzYXJ5XG4gICAgICAgIGNvbnN0IGFkZHJlc3M2ID0gbmV3IEFkZHJlc3M2KHRoaXMuY29ycmVjdEZvcm0oKSk7XG4gICAgICAgIGlmIChhZGRyZXNzNi5lbGlkZWRHcm91cHMgPT09IDApIHtcbiAgICAgICAgICAgIC8vIFRoZSBzaW1wbGUgY2FzZVxuICAgICAgICAgICAgb3V0cHV0LnB1c2goKDAsIHJlZ3VsYXJfZXhwcmVzc2lvbnNfMS5zaW1wbGVSZWd1bGFyRXhwcmVzc2lvbikoYWRkcmVzczYucGFyc2VkQWRkcmVzcykpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGFkZHJlc3M2LmVsaWRlZEdyb3VwcyA9PT0gY29uc3RhbnRzNi5HUk9VUFMpIHtcbiAgICAgICAgICAgIC8vIEEgY29tcGxldGVseSBlbGlkZWQgYWRkcmVzc1xuICAgICAgICAgICAgb3V0cHV0LnB1c2goKDAsIHJlZ3VsYXJfZXhwcmVzc2lvbnNfMS5wb3NzaWJsZUVsaXNpb25zKShjb25zdGFudHM2LkdST1VQUykpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gQSBwYXJ0aWFsbHkgZWxpZGVkIGFkZHJlc3NcbiAgICAgICAgICAgIGNvbnN0IGhhbHZlcyA9IGFkZHJlc3M2LmFkZHJlc3Muc3BsaXQoJzo6Jyk7XG4gICAgICAgICAgICBpZiAoaGFsdmVzWzBdLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIG91dHB1dC5wdXNoKCgwLCByZWd1bGFyX2V4cHJlc3Npb25zXzEuc2ltcGxlUmVndWxhckV4cHJlc3Npb24pKGhhbHZlc1swXS5zcGxpdCgnOicpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhc3NlcnQodHlwZW9mIGFkZHJlc3M2LmVsaWRlZEdyb3VwcyA9PT0gJ251bWJlcicpO1xuICAgICAgICAgICAgb3V0cHV0LnB1c2goKDAsIHJlZ3VsYXJfZXhwcmVzc2lvbnNfMS5wb3NzaWJsZUVsaXNpb25zKShhZGRyZXNzNi5lbGlkZWRHcm91cHMsIGhhbHZlc1swXS5sZW5ndGggIT09IDAsIGhhbHZlc1sxXS5sZW5ndGggIT09IDApKTtcbiAgICAgICAgICAgIGlmIChoYWx2ZXNbMV0ubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgb3V0cHV0LnB1c2goKDAsIHJlZ3VsYXJfZXhwcmVzc2lvbnNfMS5zaW1wbGVSZWd1bGFyRXhwcmVzc2lvbikoaGFsdmVzWzFdLnNwbGl0KCc6JykpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG91dHB1dCA9IFtvdXRwdXQuam9pbignOicpXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXN1YnN0cmluZ1NlYXJjaCkge1xuICAgICAgICAgICAgb3V0cHV0ID0gW1xuICAgICAgICAgICAgICAgICcoPz1efCcsXG4gICAgICAgICAgICAgICAgcmVndWxhcl9leHByZXNzaW9uc18xLkFERFJFU1NfQk9VTkRBUlksXG4gICAgICAgICAgICAgICAgJ3xbXlxcXFx3XFxcXDpdKSgnLFxuICAgICAgICAgICAgICAgIC4uLm91dHB1dCxcbiAgICAgICAgICAgICAgICAnKSg/PVteXFxcXHdcXFxcOl18JyxcbiAgICAgICAgICAgICAgICByZWd1bGFyX2V4cHJlc3Npb25zXzEuQUREUkVTU19CT1VOREFSWSxcbiAgICAgICAgICAgICAgICAnfCQpJyxcbiAgICAgICAgICAgIF07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG91dHB1dC5qb2luKCcnKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2VuZXJhdGUgYSByZWd1bGFyIGV4cHJlc3Npb24gdGhhdCBjYW4gYmUgdXNlZCB0byBmaW5kIG9yIHZhbGlkYXRlIGFsbFxuICAgICAqIHZhcmlhdGlvbnMgb2YgdGhpcyBhZGRyZXNzLlxuICAgICAqIEBtZW1iZXJvZiBBZGRyZXNzNlxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gc3Vic3RyaW5nU2VhcmNoXG4gICAgICogQHJldHVybnMge1JlZ0V4cH1cbiAgICAgKi9cbiAgICByZWd1bGFyRXhwcmVzc2lvbihzdWJzdHJpbmdTZWFyY2ggPSBmYWxzZSkge1xuICAgICAgICByZXR1cm4gbmV3IFJlZ0V4cCh0aGlzLnJlZ3VsYXJFeHByZXNzaW9uU3RyaW5nKHN1YnN0cmluZ1NlYXJjaCksICdpJyk7XG4gICAgfVxufVxuZXhwb3J0cy5BZGRyZXNzNiA9IEFkZHJlc3M2O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aXB2Ni5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ip-address/dist/ipv6.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ip-address/dist/v4/constants.js":
/*!******************************************************!*\
  !*** ./node_modules/ip-address/dist/v4/constants.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.RE_SUBNET_STRING = exports.RE_ADDRESS = exports.GROUPS = exports.BITS = void 0;\nexports.BITS = 32;\nexports.GROUPS = 4;\nexports.RE_ADDRESS = /^(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/g;\nexports.RE_SUBNET_STRING = /\\/\\d{1,2}$/;\n//# sourceMappingURL=constants.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaXAtYWRkcmVzcy9kaXN0L3Y0L2NvbnN0YW50cy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCx3QkFBd0IsR0FBRyxrQkFBa0IsR0FBRyxjQUFjLEdBQUcsWUFBWTtBQUM3RSxZQUFZO0FBQ1osY0FBYztBQUNkLGtCQUFrQjtBQUNsQix3QkFBd0IsU0FBUyxJQUFJO0FBQ3JDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbWVyY2hhbnRhaS1hZG1pbi8uL25vZGVfbW9kdWxlcy9pcC1hZGRyZXNzL2Rpc3QvdjQvY29uc3RhbnRzLmpzP2FjZjIiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlJFX1NVQk5FVF9TVFJJTkcgPSBleHBvcnRzLlJFX0FERFJFU1MgPSBleHBvcnRzLkdST1VQUyA9IGV4cG9ydHMuQklUUyA9IHZvaWQgMDtcbmV4cG9ydHMuQklUUyA9IDMyO1xuZXhwb3J0cy5HUk9VUFMgPSA0O1xuZXhwb3J0cy5SRV9BRERSRVNTID0gL14oMjVbMC01XXwyWzAtNF1bMC05XXxbMDFdP1swLTldWzAtOV0/KVxcLigyNVswLTVdfDJbMC00XVswLTldfFswMV0/WzAtOV1bMC05XT8pXFwuKDI1WzAtNV18MlswLTRdWzAtOV18WzAxXT9bMC05XVswLTldPylcXC4oMjVbMC01XXwyWzAtNF1bMC05XXxbMDFdP1swLTldWzAtOV0/KSQvZztcbmV4cG9ydHMuUkVfU1VCTkVUX1NUUklORyA9IC9cXC9cXGR7MSwyfSQvO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29uc3RhbnRzLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ip-address/dist/v4/constants.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ip-address/dist/v6/constants.js":
/*!******************************************************!*\
  !*** ./node_modules/ip-address/dist/v6/constants.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.RE_URL_WITH_PORT = exports.RE_URL = exports.RE_ZONE_STRING = exports.RE_SUBNET_STRING = exports.RE_BAD_ADDRESS = exports.RE_BAD_CHARACTERS = exports.TYPES = exports.SCOPES = exports.GROUPS = exports.BITS = void 0;\nexports.BITS = 128;\nexports.GROUPS = 8;\n/**\n * Represents IPv6 address scopes\n * @memberof Address6\n * @static\n */\nexports.SCOPES = {\n    0: 'Reserved',\n    1: 'Interface local',\n    2: 'Link local',\n    4: 'Admin local',\n    5: 'Site local',\n    8: 'Organization local',\n    14: 'Global',\n    15: 'Reserved',\n};\n/**\n * Represents IPv6 address types\n * @memberof Address6\n * @static\n */\nexports.TYPES = {\n    'ff01::1/128': 'Multicast (All nodes on this interface)',\n    'ff01::2/128': 'Multicast (All routers on this interface)',\n    'ff02::1/128': 'Multicast (All nodes on this link)',\n    'ff02::2/128': 'Multicast (All routers on this link)',\n    'ff05::2/128': 'Multicast (All routers in this site)',\n    'ff02::5/128': 'Multicast (OSPFv3 AllSPF routers)',\n    'ff02::6/128': 'Multicast (OSPFv3 AllDR routers)',\n    'ff02::9/128': 'Multicast (RIP routers)',\n    'ff02::a/128': 'Multicast (EIGRP routers)',\n    'ff02::d/128': 'Multicast (PIM routers)',\n    'ff02::16/128': 'Multicast (MLDv2 reports)',\n    'ff01::fb/128': 'Multicast (mDNSv6)',\n    'ff02::fb/128': 'Multicast (mDNSv6)',\n    'ff05::fb/128': 'Multicast (mDNSv6)',\n    'ff02::1:2/128': 'Multicast (All DHCP servers and relay agents on this link)',\n    'ff05::1:2/128': 'Multicast (All DHCP servers and relay agents in this site)',\n    'ff02::1:3/128': 'Multicast (All DHCP servers on this link)',\n    'ff05::1:3/128': 'Multicast (All DHCP servers in this site)',\n    '::/128': 'Unspecified',\n    '::1/128': 'Loopback',\n    'ff00::/8': 'Multicast',\n    'fe80::/10': 'Link-local unicast',\n};\n/**\n * A regular expression that matches bad characters in an IPv6 address\n * @memberof Address6\n * @static\n */\nexports.RE_BAD_CHARACTERS = /([^0-9a-f:/%])/gi;\n/**\n * A regular expression that matches an incorrect IPv6 address\n * @memberof Address6\n * @static\n */\nexports.RE_BAD_ADDRESS = /([0-9a-f]{5,}|:{3,}|[^:]:$|^:[^:]|\\/$)/gi;\n/**\n * A regular expression that matches an IPv6 subnet\n * @memberof Address6\n * @static\n */\nexports.RE_SUBNET_STRING = /\\/\\d{1,3}(?=%|$)/;\n/**\n * A regular expression that matches an IPv6 zone\n * @memberof Address6\n * @static\n */\nexports.RE_ZONE_STRING = /%.*$/;\nexports.RE_URL = /^\\[{0,1}([0-9a-f:]+)\\]{0,1}/;\nexports.RE_URL_WITH_PORT = /\\[([0-9a-f:]+)\\]:([0-9]{1,5})/;\n//# sourceMappingURL=constants.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaXAtYWRkcmVzcy9kaXN0L3Y2L2NvbnN0YW50cy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCx3QkFBd0IsR0FBRyxjQUFjLEdBQUcsc0JBQXNCLEdBQUcsd0JBQXdCLEdBQUcsc0JBQXNCLEdBQUcseUJBQXlCLEdBQUcsYUFBYSxHQUFHLGNBQWMsR0FBRyxjQUFjLEdBQUcsWUFBWTtBQUNuTixZQUFZO0FBQ1osY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGNBQWMsR0FBRyxHQUFHLEdBQUc7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixTQUFTLElBQUk7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QixjQUFjLFFBQVEsSUFBSSxlQUFlLElBQUk7QUFDN0Msd0JBQXdCLDRCQUE0QixJQUFJO0FBQ3hEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbWVyY2hhbnRhaS1hZG1pbi8uL25vZGVfbW9kdWxlcy9pcC1hZGRyZXNzL2Rpc3QvdjYvY29uc3RhbnRzLmpzP2Q3MWIiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlJFX1VSTF9XSVRIX1BPUlQgPSBleHBvcnRzLlJFX1VSTCA9IGV4cG9ydHMuUkVfWk9ORV9TVFJJTkcgPSBleHBvcnRzLlJFX1NVQk5FVF9TVFJJTkcgPSBleHBvcnRzLlJFX0JBRF9BRERSRVNTID0gZXhwb3J0cy5SRV9CQURfQ0hBUkFDVEVSUyA9IGV4cG9ydHMuVFlQRVMgPSBleHBvcnRzLlNDT1BFUyA9IGV4cG9ydHMuR1JPVVBTID0gZXhwb3J0cy5CSVRTID0gdm9pZCAwO1xuZXhwb3J0cy5CSVRTID0gMTI4O1xuZXhwb3J0cy5HUk9VUFMgPSA4O1xuLyoqXG4gKiBSZXByZXNlbnRzIElQdjYgYWRkcmVzcyBzY29wZXNcbiAqIEBtZW1iZXJvZiBBZGRyZXNzNlxuICogQHN0YXRpY1xuICovXG5leHBvcnRzLlNDT1BFUyA9IHtcbiAgICAwOiAnUmVzZXJ2ZWQnLFxuICAgIDE6ICdJbnRlcmZhY2UgbG9jYWwnLFxuICAgIDI6ICdMaW5rIGxvY2FsJyxcbiAgICA0OiAnQWRtaW4gbG9jYWwnLFxuICAgIDU6ICdTaXRlIGxvY2FsJyxcbiAgICA4OiAnT3JnYW5pemF0aW9uIGxvY2FsJyxcbiAgICAxNDogJ0dsb2JhbCcsXG4gICAgMTU6ICdSZXNlcnZlZCcsXG59O1xuLyoqXG4gKiBSZXByZXNlbnRzIElQdjYgYWRkcmVzcyB0eXBlc1xuICogQG1lbWJlcm9mIEFkZHJlc3M2XG4gKiBAc3RhdGljXG4gKi9cbmV4cG9ydHMuVFlQRVMgPSB7XG4gICAgJ2ZmMDE6OjEvMTI4JzogJ011bHRpY2FzdCAoQWxsIG5vZGVzIG9uIHRoaXMgaW50ZXJmYWNlKScsXG4gICAgJ2ZmMDE6OjIvMTI4JzogJ011bHRpY2FzdCAoQWxsIHJvdXRlcnMgb24gdGhpcyBpbnRlcmZhY2UpJyxcbiAgICAnZmYwMjo6MS8xMjgnOiAnTXVsdGljYXN0IChBbGwgbm9kZXMgb24gdGhpcyBsaW5rKScsXG4gICAgJ2ZmMDI6OjIvMTI4JzogJ011bHRpY2FzdCAoQWxsIHJvdXRlcnMgb24gdGhpcyBsaW5rKScsXG4gICAgJ2ZmMDU6OjIvMTI4JzogJ011bHRpY2FzdCAoQWxsIHJvdXRlcnMgaW4gdGhpcyBzaXRlKScsXG4gICAgJ2ZmMDI6OjUvMTI4JzogJ011bHRpY2FzdCAoT1NQRnYzIEFsbFNQRiByb3V0ZXJzKScsXG4gICAgJ2ZmMDI6OjYvMTI4JzogJ011bHRpY2FzdCAoT1NQRnYzIEFsbERSIHJvdXRlcnMpJyxcbiAgICAnZmYwMjo6OS8xMjgnOiAnTXVsdGljYXN0IChSSVAgcm91dGVycyknLFxuICAgICdmZjAyOjphLzEyOCc6ICdNdWx0aWNhc3QgKEVJR1JQIHJvdXRlcnMpJyxcbiAgICAnZmYwMjo6ZC8xMjgnOiAnTXVsdGljYXN0IChQSU0gcm91dGVycyknLFxuICAgICdmZjAyOjoxNi8xMjgnOiAnTXVsdGljYXN0IChNTER2MiByZXBvcnRzKScsXG4gICAgJ2ZmMDE6OmZiLzEyOCc6ICdNdWx0aWNhc3QgKG1ETlN2NiknLFxuICAgICdmZjAyOjpmYi8xMjgnOiAnTXVsdGljYXN0IChtRE5TdjYpJyxcbiAgICAnZmYwNTo6ZmIvMTI4JzogJ011bHRpY2FzdCAobUROU3Y2KScsXG4gICAgJ2ZmMDI6OjE6Mi8xMjgnOiAnTXVsdGljYXN0IChBbGwgREhDUCBzZXJ2ZXJzIGFuZCByZWxheSBhZ2VudHMgb24gdGhpcyBsaW5rKScsXG4gICAgJ2ZmMDU6OjE6Mi8xMjgnOiAnTXVsdGljYXN0IChBbGwgREhDUCBzZXJ2ZXJzIGFuZCByZWxheSBhZ2VudHMgaW4gdGhpcyBzaXRlKScsXG4gICAgJ2ZmMDI6OjE6My8xMjgnOiAnTXVsdGljYXN0IChBbGwgREhDUCBzZXJ2ZXJzIG9uIHRoaXMgbGluayknLFxuICAgICdmZjA1OjoxOjMvMTI4JzogJ011bHRpY2FzdCAoQWxsIERIQ1Agc2VydmVycyBpbiB0aGlzIHNpdGUpJyxcbiAgICAnOjovMTI4JzogJ1Vuc3BlY2lmaWVkJyxcbiAgICAnOjoxLzEyOCc6ICdMb29wYmFjaycsXG4gICAgJ2ZmMDA6Oi84JzogJ011bHRpY2FzdCcsXG4gICAgJ2ZlODA6Oi8xMCc6ICdMaW5rLWxvY2FsIHVuaWNhc3QnLFxufTtcbi8qKlxuICogQSByZWd1bGFyIGV4cHJlc3Npb24gdGhhdCBtYXRjaGVzIGJhZCBjaGFyYWN0ZXJzIGluIGFuIElQdjYgYWRkcmVzc1xuICogQG1lbWJlcm9mIEFkZHJlc3M2XG4gKiBAc3RhdGljXG4gKi9cbmV4cG9ydHMuUkVfQkFEX0NIQVJBQ1RFUlMgPSAvKFteMC05YS1mOi8lXSkvZ2k7XG4vKipcbiAqIEEgcmVndWxhciBleHByZXNzaW9uIHRoYXQgbWF0Y2hlcyBhbiBpbmNvcnJlY3QgSVB2NiBhZGRyZXNzXG4gKiBAbWVtYmVyb2YgQWRkcmVzczZcbiAqIEBzdGF0aWNcbiAqL1xuZXhwb3J0cy5SRV9CQURfQUREUkVTUyA9IC8oWzAtOWEtZl17NSx9fDp7Myx9fFteOl06JHxeOlteOl18XFwvJCkvZ2k7XG4vKipcbiAqIEEgcmVndWxhciBleHByZXNzaW9uIHRoYXQgbWF0Y2hlcyBhbiBJUHY2IHN1Ym5ldFxuICogQG1lbWJlcm9mIEFkZHJlc3M2XG4gKiBAc3RhdGljXG4gKi9cbmV4cG9ydHMuUkVfU1VCTkVUX1NUUklORyA9IC9cXC9cXGR7MSwzfSg/PSV8JCkvO1xuLyoqXG4gKiBBIHJlZ3VsYXIgZXhwcmVzc2lvbiB0aGF0IG1hdGNoZXMgYW4gSVB2NiB6b25lXG4gKiBAbWVtYmVyb2YgQWRkcmVzczZcbiAqIEBzdGF0aWNcbiAqL1xuZXhwb3J0cy5SRV9aT05FX1NUUklORyA9IC8lLiokLztcbmV4cG9ydHMuUkVfVVJMID0gL15cXFt7MCwxfShbMC05YS1mOl0rKVxcXXswLDF9LztcbmV4cG9ydHMuUkVfVVJMX1dJVEhfUE9SVCA9IC9cXFsoWzAtOWEtZjpdKylcXF06KFswLTldezEsNX0pLztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbnN0YW50cy5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ip-address/dist/v6/constants.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ip-address/dist/v6/helpers.js":
/*!****************************************************!*\
  !*** ./node_modules/ip-address/dist/v6/helpers.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.spanAllZeroes = spanAllZeroes;\nexports.spanAll = spanAll;\nexports.spanLeadingZeroes = spanLeadingZeroes;\nexports.simpleGroup = simpleGroup;\n/**\n * @returns {String} the string with all zeroes contained in a <span>\n */\nfunction spanAllZeroes(s) {\n    return s.replace(/(0+)/g, '<span class=\"zero\">$1</span>');\n}\n/**\n * @returns {String} the string with each character contained in a <span>\n */\nfunction spanAll(s, offset = 0) {\n    const letters = s.split('');\n    return letters\n        .map((n, i) => `<span class=\"digit value-${n} position-${i + offset}\">${spanAllZeroes(n)}</span>`)\n        .join('');\n}\nfunction spanLeadingZeroesSimple(group) {\n    return group.replace(/^(0+)/, '<span class=\"zero\">$1</span>');\n}\n/**\n * @returns {String} the string with leading zeroes contained in a <span>\n */\nfunction spanLeadingZeroes(address) {\n    const groups = address.split(':');\n    return groups.map((g) => spanLeadingZeroesSimple(g)).join(':');\n}\n/**\n * Groups an address\n * @returns {String} a grouped address\n */\nfunction simpleGroup(addressString, offset = 0) {\n    const groups = addressString.split(':');\n    return groups.map((g, i) => {\n        if (/group-v4/.test(g)) {\n            return g;\n        }\n        return `<span class=\"hover-group group-${i + offset}\">${spanLeadingZeroesSimple(g)}</span>`;\n    });\n}\n//# sourceMappingURL=helpers.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaXAtYWRkcmVzcy9kaXN0L3Y2L2hlbHBlcnMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QscUJBQXFCO0FBQ3JCLGVBQWU7QUFDZix5QkFBeUI7QUFDekIsbUJBQW1CO0FBQ25CO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsR0FBRyxXQUFXLFdBQVcsSUFBSSxpQkFBaUI7QUFDakc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELFdBQVcsSUFBSSwyQkFBMkI7QUFDM0YsS0FBSztBQUNMO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9tZXJjaGFudGFpLWFkbWluLy4vbm9kZV9tb2R1bGVzL2lwLWFkZHJlc3MvZGlzdC92Ni9oZWxwZXJzLmpzP2RmNDgiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnNwYW5BbGxaZXJvZXMgPSBzcGFuQWxsWmVyb2VzO1xuZXhwb3J0cy5zcGFuQWxsID0gc3BhbkFsbDtcbmV4cG9ydHMuc3BhbkxlYWRpbmdaZXJvZXMgPSBzcGFuTGVhZGluZ1plcm9lcztcbmV4cG9ydHMuc2ltcGxlR3JvdXAgPSBzaW1wbGVHcm91cDtcbi8qKlxuICogQHJldHVybnMge1N0cmluZ30gdGhlIHN0cmluZyB3aXRoIGFsbCB6ZXJvZXMgY29udGFpbmVkIGluIGEgPHNwYW4+XG4gKi9cbmZ1bmN0aW9uIHNwYW5BbGxaZXJvZXMocykge1xuICAgIHJldHVybiBzLnJlcGxhY2UoLygwKykvZywgJzxzcGFuIGNsYXNzPVwiemVyb1wiPiQxPC9zcGFuPicpO1xufVxuLyoqXG4gKiBAcmV0dXJucyB7U3RyaW5nfSB0aGUgc3RyaW5nIHdpdGggZWFjaCBjaGFyYWN0ZXIgY29udGFpbmVkIGluIGEgPHNwYW4+XG4gKi9cbmZ1bmN0aW9uIHNwYW5BbGwocywgb2Zmc2V0ID0gMCkge1xuICAgIGNvbnN0IGxldHRlcnMgPSBzLnNwbGl0KCcnKTtcbiAgICByZXR1cm4gbGV0dGVyc1xuICAgICAgICAubWFwKChuLCBpKSA9PiBgPHNwYW4gY2xhc3M9XCJkaWdpdCB2YWx1ZS0ke259IHBvc2l0aW9uLSR7aSArIG9mZnNldH1cIj4ke3NwYW5BbGxaZXJvZXMobil9PC9zcGFuPmApXG4gICAgICAgIC5qb2luKCcnKTtcbn1cbmZ1bmN0aW9uIHNwYW5MZWFkaW5nWmVyb2VzU2ltcGxlKGdyb3VwKSB7XG4gICAgcmV0dXJuIGdyb3VwLnJlcGxhY2UoL14oMCspLywgJzxzcGFuIGNsYXNzPVwiemVyb1wiPiQxPC9zcGFuPicpO1xufVxuLyoqXG4gKiBAcmV0dXJucyB7U3RyaW5nfSB0aGUgc3RyaW5nIHdpdGggbGVhZGluZyB6ZXJvZXMgY29udGFpbmVkIGluIGEgPHNwYW4+XG4gKi9cbmZ1bmN0aW9uIHNwYW5MZWFkaW5nWmVyb2VzKGFkZHJlc3MpIHtcbiAgICBjb25zdCBncm91cHMgPSBhZGRyZXNzLnNwbGl0KCc6Jyk7XG4gICAgcmV0dXJuIGdyb3Vwcy5tYXAoKGcpID0+IHNwYW5MZWFkaW5nWmVyb2VzU2ltcGxlKGcpKS5qb2luKCc6Jyk7XG59XG4vKipcbiAqIEdyb3VwcyBhbiBhZGRyZXNzXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBhIGdyb3VwZWQgYWRkcmVzc1xuICovXG5mdW5jdGlvbiBzaW1wbGVHcm91cChhZGRyZXNzU3RyaW5nLCBvZmZzZXQgPSAwKSB7XG4gICAgY29uc3QgZ3JvdXBzID0gYWRkcmVzc1N0cmluZy5zcGxpdCgnOicpO1xuICAgIHJldHVybiBncm91cHMubWFwKChnLCBpKSA9PiB7XG4gICAgICAgIGlmICgvZ3JvdXAtdjQvLnRlc3QoZykpIHtcbiAgICAgICAgICAgIHJldHVybiBnO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBgPHNwYW4gY2xhc3M9XCJob3Zlci1ncm91cCBncm91cC0ke2kgKyBvZmZzZXR9XCI+JHtzcGFuTGVhZGluZ1plcm9lc1NpbXBsZShnKX08L3NwYW4+YDtcbiAgICB9KTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWhlbHBlcnMuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ip-address/dist/v6/helpers.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ip-address/dist/v6/regular-expressions.js":
/*!****************************************************************!*\
  !*** ./node_modules/ip-address/dist/v6/regular-expressions.js ***!
  \****************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ADDRESS_BOUNDARY = void 0;\nexports.groupPossibilities = groupPossibilities;\nexports.padGroup = padGroup;\nexports.simpleRegularExpression = simpleRegularExpression;\nexports.possibleElisions = possibleElisions;\nconst v6 = __importStar(__webpack_require__(/*! ./constants */ \"(rsc)/./node_modules/ip-address/dist/v6/constants.js\"));\nfunction groupPossibilities(possibilities) {\n    return `(${possibilities.join('|')})`;\n}\nfunction padGroup(group) {\n    if (group.length < 4) {\n        return `0{0,${4 - group.length}}${group}`;\n    }\n    return group;\n}\nexports.ADDRESS_BOUNDARY = '[^A-Fa-f0-9:]';\nfunction simpleRegularExpression(groups) {\n    const zeroIndexes = [];\n    groups.forEach((group, i) => {\n        const groupInteger = parseInt(group, 16);\n        if (groupInteger === 0) {\n            zeroIndexes.push(i);\n        }\n    });\n    // You can technically elide a single 0, this creates the regular expressions\n    // to match that eventuality\n    const possibilities = zeroIndexes.map((zeroIndex) => groups\n        .map((group, i) => {\n        if (i === zeroIndex) {\n            const elision = i === 0 || i === v6.GROUPS - 1 ? ':' : '';\n            return groupPossibilities([padGroup(group), elision]);\n        }\n        return padGroup(group);\n    })\n        .join(':'));\n    // The simplest case\n    possibilities.push(groups.map(padGroup).join(':'));\n    return groupPossibilities(possibilities);\n}\nfunction possibleElisions(elidedGroups, moreLeft, moreRight) {\n    const left = moreLeft ? '' : ':';\n    const right = moreRight ? '' : ':';\n    const possibilities = [];\n    // 1. elision of everything (::)\n    if (!moreLeft && !moreRight) {\n        possibilities.push('::');\n    }\n    // 2. complete elision of the middle\n    if (moreLeft && moreRight) {\n        possibilities.push('');\n    }\n    if ((moreRight && !moreLeft) || (!moreRight && moreLeft)) {\n        // 3. complete elision of one side\n        possibilities.push(':');\n    }\n    // 4. elision from the left side\n    possibilities.push(`${left}(:0{1,4}){1,${elidedGroups - 1}}`);\n    // 5. elision from the right side\n    possibilities.push(`(0{1,4}:){1,${elidedGroups - 1}}${right}`);\n    // 6. no elision\n    possibilities.push(`(0{1,4}:){${elidedGroups - 1}}0{1,4}`);\n    // 7. elision (including sloppy elision) from the middle\n    for (let groups = 1; groups < elidedGroups - 1; groups++) {\n        for (let position = 1; position < elidedGroups - groups; position++) {\n            possibilities.push(`(0{1,4}:){${position}}:(0{1,4}:){${elidedGroups - position - groups - 1}}0{1,4}`);\n        }\n    }\n    return groupPossibilities(possibilities);\n}\n//# sourceMappingURL=regular-expressions.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaXAtYWRkcmVzcy9kaXN0L3Y2L3JlZ3VsYXItZXhwcmVzc2lvbnMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsb0NBQW9DO0FBQ25EO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLDBDQUEwQyw0QkFBNEI7QUFDdEUsQ0FBQztBQUNEO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHdCQUF3QjtBQUN4QiwwQkFBMEI7QUFDMUIsZ0JBQWdCO0FBQ2hCLCtCQUErQjtBQUMvQix3QkFBd0I7QUFDeEIsd0JBQXdCLG1CQUFPLENBQUMseUVBQWE7QUFDN0M7QUFDQSxlQUFlLHdCQUF3QjtBQUN2QztBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsSUFBSSxrQkFBa0IsRUFBRSxNQUFNO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsS0FBSyxJQUFJLElBQUksRUFBRSxJQUFJLGtCQUFrQjtBQUMvRDtBQUNBLDJCQUEyQixJQUFJLEdBQUcsSUFBSSxrQkFBa0IsRUFBRSxNQUFNO0FBQ2hFO0FBQ0EsMkJBQTJCLElBQUksR0FBRyxFQUFFLGtCQUFrQixFQUFFLElBQUk7QUFDNUQ7QUFDQSx5QkFBeUIsMkJBQTJCO0FBQ3BELCtCQUErQixrQ0FBa0M7QUFDakUsbUNBQW1DLElBQUksR0FBRyxFQUFFLFVBQVUsSUFBSSxJQUFJLEdBQUcsRUFBRSxzQ0FBc0MsRUFBRSxJQUFJO0FBQy9HO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9tZXJjaGFudGFpLWFkbWluLy4vbm9kZV9tb2R1bGVzL2lwLWFkZHJlc3MvZGlzdC92Ni9yZWd1bGFyLWV4cHJlc3Npb25zLmpzP2MzMGIiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IobSwgayk7XG4gICAgaWYgKCFkZXNjIHx8IChcImdldFwiIGluIGRlc2MgPyAhbS5fX2VzTW9kdWxlIDogZGVzYy53cml0YWJsZSB8fCBkZXNjLmNvbmZpZ3VyYWJsZSkpIHtcbiAgICAgIGRlc2MgPSB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH07XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgZGVzYyk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fc2V0TW9kdWxlRGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19zZXRNb2R1bGVEZWZhdWx0KSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCB2KSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIFwiZGVmYXVsdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2IH0pO1xufSkgOiBmdW5jdGlvbihvLCB2KSB7XG4gICAgb1tcImRlZmF1bHRcIl0gPSB2O1xufSk7XG52YXIgX19pbXBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydFN0YXIpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoayAhPT0gXCJkZWZhdWx0XCIgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIF9fY3JlYXRlQmluZGluZyhyZXN1bHQsIG1vZCwgayk7XG4gICAgX19zZXRNb2R1bGVEZWZhdWx0KHJlc3VsdCwgbW9kKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQUREUkVTU19CT1VOREFSWSA9IHZvaWQgMDtcbmV4cG9ydHMuZ3JvdXBQb3NzaWJpbGl0aWVzID0gZ3JvdXBQb3NzaWJpbGl0aWVzO1xuZXhwb3J0cy5wYWRHcm91cCA9IHBhZEdyb3VwO1xuZXhwb3J0cy5zaW1wbGVSZWd1bGFyRXhwcmVzc2lvbiA9IHNpbXBsZVJlZ3VsYXJFeHByZXNzaW9uO1xuZXhwb3J0cy5wb3NzaWJsZUVsaXNpb25zID0gcG9zc2libGVFbGlzaW9ucztcbmNvbnN0IHY2ID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCIuL2NvbnN0YW50c1wiKSk7XG5mdW5jdGlvbiBncm91cFBvc3NpYmlsaXRpZXMocG9zc2liaWxpdGllcykge1xuICAgIHJldHVybiBgKCR7cG9zc2liaWxpdGllcy5qb2luKCd8Jyl9KWA7XG59XG5mdW5jdGlvbiBwYWRHcm91cChncm91cCkge1xuICAgIGlmIChncm91cC5sZW5ndGggPCA0KSB7XG4gICAgICAgIHJldHVybiBgMHswLCR7NCAtIGdyb3VwLmxlbmd0aH19JHtncm91cH1gO1xuICAgIH1cbiAgICByZXR1cm4gZ3JvdXA7XG59XG5leHBvcnRzLkFERFJFU1NfQk9VTkRBUlkgPSAnW15BLUZhLWYwLTk6XSc7XG5mdW5jdGlvbiBzaW1wbGVSZWd1bGFyRXhwcmVzc2lvbihncm91cHMpIHtcbiAgICBjb25zdCB6ZXJvSW5kZXhlcyA9IFtdO1xuICAgIGdyb3Vwcy5mb3JFYWNoKChncm91cCwgaSkgPT4ge1xuICAgICAgICBjb25zdCBncm91cEludGVnZXIgPSBwYXJzZUludChncm91cCwgMTYpO1xuICAgICAgICBpZiAoZ3JvdXBJbnRlZ2VyID09PSAwKSB7XG4gICAgICAgICAgICB6ZXJvSW5kZXhlcy5wdXNoKGkpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgLy8gWW91IGNhbiB0ZWNobmljYWxseSBlbGlkZSBhIHNpbmdsZSAwLCB0aGlzIGNyZWF0ZXMgdGhlIHJlZ3VsYXIgZXhwcmVzc2lvbnNcbiAgICAvLyB0byBtYXRjaCB0aGF0IGV2ZW50dWFsaXR5XG4gICAgY29uc3QgcG9zc2liaWxpdGllcyA9IHplcm9JbmRleGVzLm1hcCgoemVyb0luZGV4KSA9PiBncm91cHNcbiAgICAgICAgLm1hcCgoZ3JvdXAsIGkpID0+IHtcbiAgICAgICAgaWYgKGkgPT09IHplcm9JbmRleCkge1xuICAgICAgICAgICAgY29uc3QgZWxpc2lvbiA9IGkgPT09IDAgfHwgaSA9PT0gdjYuR1JPVVBTIC0gMSA/ICc6JyA6ICcnO1xuICAgICAgICAgICAgcmV0dXJuIGdyb3VwUG9zc2liaWxpdGllcyhbcGFkR3JvdXAoZ3JvdXApLCBlbGlzaW9uXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBhZEdyb3VwKGdyb3VwKTtcbiAgICB9KVxuICAgICAgICAuam9pbignOicpKTtcbiAgICAvLyBUaGUgc2ltcGxlc3QgY2FzZVxuICAgIHBvc3NpYmlsaXRpZXMucHVzaChncm91cHMubWFwKHBhZEdyb3VwKS5qb2luKCc6JykpO1xuICAgIHJldHVybiBncm91cFBvc3NpYmlsaXRpZXMocG9zc2liaWxpdGllcyk7XG59XG5mdW5jdGlvbiBwb3NzaWJsZUVsaXNpb25zKGVsaWRlZEdyb3VwcywgbW9yZUxlZnQsIG1vcmVSaWdodCkge1xuICAgIGNvbnN0IGxlZnQgPSBtb3JlTGVmdCA/ICcnIDogJzonO1xuICAgIGNvbnN0IHJpZ2h0ID0gbW9yZVJpZ2h0ID8gJycgOiAnOic7XG4gICAgY29uc3QgcG9zc2liaWxpdGllcyA9IFtdO1xuICAgIC8vIDEuIGVsaXNpb24gb2YgZXZlcnl0aGluZyAoOjopXG4gICAgaWYgKCFtb3JlTGVmdCAmJiAhbW9yZVJpZ2h0KSB7XG4gICAgICAgIHBvc3NpYmlsaXRpZXMucHVzaCgnOjonKTtcbiAgICB9XG4gICAgLy8gMi4gY29tcGxldGUgZWxpc2lvbiBvZiB0aGUgbWlkZGxlXG4gICAgaWYgKG1vcmVMZWZ0ICYmIG1vcmVSaWdodCkge1xuICAgICAgICBwb3NzaWJpbGl0aWVzLnB1c2goJycpO1xuICAgIH1cbiAgICBpZiAoKG1vcmVSaWdodCAmJiAhbW9yZUxlZnQpIHx8ICghbW9yZVJpZ2h0ICYmIG1vcmVMZWZ0KSkge1xuICAgICAgICAvLyAzLiBjb21wbGV0ZSBlbGlzaW9uIG9mIG9uZSBzaWRlXG4gICAgICAgIHBvc3NpYmlsaXRpZXMucHVzaCgnOicpO1xuICAgIH1cbiAgICAvLyA0LiBlbGlzaW9uIGZyb20gdGhlIGxlZnQgc2lkZVxuICAgIHBvc3NpYmlsaXRpZXMucHVzaChgJHtsZWZ0fSg6MHsxLDR9KXsxLCR7ZWxpZGVkR3JvdXBzIC0gMX19YCk7XG4gICAgLy8gNS4gZWxpc2lvbiBmcm9tIHRoZSByaWdodCBzaWRlXG4gICAgcG9zc2liaWxpdGllcy5wdXNoKGAoMHsxLDR9Oil7MSwke2VsaWRlZEdyb3VwcyAtIDF9fSR7cmlnaHR9YCk7XG4gICAgLy8gNi4gbm8gZWxpc2lvblxuICAgIHBvc3NpYmlsaXRpZXMucHVzaChgKDB7MSw0fTopeyR7ZWxpZGVkR3JvdXBzIC0gMX19MHsxLDR9YCk7XG4gICAgLy8gNy4gZWxpc2lvbiAoaW5jbHVkaW5nIHNsb3BweSBlbGlzaW9uKSBmcm9tIHRoZSBtaWRkbGVcbiAgICBmb3IgKGxldCBncm91cHMgPSAxOyBncm91cHMgPCBlbGlkZWRHcm91cHMgLSAxOyBncm91cHMrKykge1xuICAgICAgICBmb3IgKGxldCBwb3NpdGlvbiA9IDE7IHBvc2l0aW9uIDwgZWxpZGVkR3JvdXBzIC0gZ3JvdXBzOyBwb3NpdGlvbisrKSB7XG4gICAgICAgICAgICBwb3NzaWJpbGl0aWVzLnB1c2goYCgwezEsNH06KXske3Bvc2l0aW9ufX06KDB7MSw0fTopeyR7ZWxpZGVkR3JvdXBzIC0gcG9zaXRpb24gLSBncm91cHMgLSAxfX0wezEsNH1gKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZ3JvdXBQb3NzaWJpbGl0aWVzKHBvc3NpYmlsaXRpZXMpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmVndWxhci1leHByZXNzaW9ucy5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ip-address/dist/v6/regular-expressions.js\n");

/***/ })

};
;